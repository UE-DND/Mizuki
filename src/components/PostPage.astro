---
import { widgetManager } from "../utils/widget-manager";
import { formatDateToYYYYMMDD } from "../utils/date-utils";
import type { DirectusPostEntry } from "@/utils/content-utils";

import PostCard from "./PostCard.astro";

interface PostListPage {
	data: DirectusPostEntry[];
}

interface Props {
	page: PostListPage;
	maxAnimationIndex?: number;
}

const { page, maxAnimationIndex } = Astro.props;

// 检查是否启用右侧边栏（通过检查右侧是否有组件）
const hasRightSidebars =
	widgetManager.getComponentsByPosition("top", "right", "desktop").length > 0 ||
	widgetManager.getComponentsByPosition("sticky", "right", "desktop").length > 0;

const initialLayoutClass = "list-mode";
---

<div
	id="post-list-container"
	class={`transition-all duration-500 ease-in-out rounded-[var(--radius-large)] bg-[var(--card-bg)] md:bg-transparent mb-4 ${initialLayoutClass}`}
	data-both-sidebars={hasRightSidebars}
>
	{
		page.data.map((entry, index) => {
			const date = formatDateToYYYYMMDD(entry.data.published);
			const [year, month] = date.split("-");
			const monthKey = `${year}-${month}`;
			return (
				<div
					class="post-list-item"
					data-year={year}
					data-month={monthKey}
					data-day={date}
					data-tags={JSON.stringify(entry.data.tags || [])}
					data-category={entry.data.category || ""}
				>
					<PostCard
						entry={entry}
						class:list="onload-animation"
						style={`--i: ${maxAnimationIndex !== undefined ? Math.min(index, maxAnimationIndex) : index}; --interval: 50ms;`}
					/>
				</div>
			);
		})
	}
</div>

<script>
	// 日历筛选逻辑
	type CalendarFilterDetail = {
		type: "day" | "month" | "year";
		key: string;
		posts: Array<{
			id: string;
			title: string;
			date: string;
			url: string;
		}>;
	};

	type RuntimeWindow = Window &
		typeof globalThis & {
			_calendarFilterListenerAttached?: boolean;
			_postCardActionsAttached?: boolean;
		};
	const runtimeWindow = window as RuntimeWindow;

	function getFilterDom() {
		return {
			postList: document.getElementById("post-list-container"),
			pagination: document.getElementById("pagination-container"),
		};
	}

	function applyCalendarFilter(detail: CalendarFilterDetail) {
		const { postList, pagination } = getFilterDom();
		if (!postList) {
			return;
		}
		const items = Array.from(postList.querySelectorAll<HTMLElement>(".post-list-item"));
		items.forEach((item) => {
			const match =
				detail.type === "year"
					? item.dataset.year === detail.key
					: detail.type === "month"
						? item.dataset.month === detail.key
						: item.dataset.day === detail.key;
			item.classList.toggle("hidden", !match);
		});
		pagination?.classList.add("hidden");
	}

	function clearCalendarFilter() {
		const { postList, pagination } = getFilterDom();
		if (!postList) {
			return;
		}
		postList
			.querySelectorAll<HTMLElement>(".post-list-item.hidden")
			.forEach((item) => item.classList.remove("hidden"));
		pagination?.classList.remove("hidden");
	}

	function setupCalendarFilterListeners() {
		if (runtimeWindow._calendarFilterListenerAttached) {
			return;
		}

		window.addEventListener("calendarFilterChange", (event) => {
			const detail = (event as CustomEvent<CalendarFilterDetail>).detail;
			if (!detail || !Array.isArray(detail.posts)) {
				return;
			}
			applyCalendarFilter(detail);
		});

		window.addEventListener("calendarFilterClear", () => {
			clearCalendarFilter();
		});

		runtimeWindow._calendarFilterListenerAttached = true;
	}

	type AuthState = {
		userId: string;
		isAdmin: boolean;
		isLoggedIn: boolean;
	};
	type CachedAuthState = {
		isLoggedIn?: boolean;
		isAdmin?: boolean;
		userId?: string;
	};
	const AUTH_STATE_CACHE_KEY = "__mizukiAuthState";
	let currentAuthState: AuthState = {
		userId: "",
		isAdmin: false,
		isLoggedIn: false,
	};

	function readCachedAuthState(): AuthState {
		const raw = (
			window as Window &
				typeof globalThis & {
					[key: string]: CachedAuthState | undefined;
				}
		)[AUTH_STATE_CACHE_KEY];
		return {
			userId: raw?.userId ? String(raw.userId) : "",
			isAdmin: Boolean(raw?.isAdmin),
			isLoggedIn: Boolean(raw?.isLoggedIn),
		};
	}

	function updateCurrentAuthState(state: AuthState) {
		currentAuthState = state;
	}

	async function applyBlockedUsersFilter() {
		if (!currentAuthState.isLoggedIn) {
			return;
		}
		try {
			const response = await fetch("/api/v1/me/blocks/?limit=200", {
				credentials: "include",
			});
			const data = await response.json().catch(() => ({}));
			if (!response.ok || !data?.ok || !Array.isArray(data.items)) {
				return;
			}
			for (const item of data.items) {
				const blockedUserId = item?.blocked_user_id
					? String(item.blocked_user_id)
					: "";
				if (blockedUserId) {
					removeCardsByAuthorId(blockedUserId);
				}
			}
		} catch (error) {
			console.error("[PostPage] failed to apply blocked user filter:", error);
		}
	}

	function updateCardActionVisibility(state: AuthState) {
		const cards = document.querySelectorAll<HTMLElement>("[data-post-card]");
		cards.forEach((card) => {
			const authorId = String(card.dataset.authorId || "");
			const deleteBtn = card.querySelector<HTMLButtonElement>(
				'button[data-action="delete-article"]',
			);
			const blockBtn = card.querySelector<HTMLButtonElement>(
				'button[data-action="block-user"]',
			);
			const reportBtn = card.querySelector<HTMLButtonElement>(
				'button[data-action="report-content"]',
			);
			const likeBtn = card.querySelector<HTMLButtonElement>(
				'button[data-action="toggle-like"]',
			);

			if (deleteBtn) {
				const canDelete =
					state.isLoggedIn &&
					Boolean(state.userId) &&
					(state.isAdmin || state.userId === authorId);
				deleteBtn.classList.toggle("hidden", !canDelete);
			}

			if (blockBtn) {
				const canBlock =
					state.isLoggedIn &&
					Boolean(authorId) &&
					state.userId !== authorId;
				blockBtn.classList.toggle("hidden", !canBlock);
			}

			if (reportBtn) {
				reportBtn.classList.toggle("hidden", !state.isLoggedIn);
			}

			if (likeBtn) {
				likeBtn.classList.toggle("opacity-60", !state.isLoggedIn);
			}
		});
	}

	function setLikeButtonState(
		button: HTMLButtonElement,
		liked: boolean,
		likeCount?: number,
	) {
		button.dataset.liked = liked ? "true" : "false";
		button.classList.toggle("text-[var(--primary)]", liked);
		const countEl = button.querySelector<HTMLElement>("[data-like-count]");
		if (countEl && typeof likeCount === "number") {
			countEl.textContent = String(Math.max(0, likeCount));
		}
	}

	async function syncLikeButtons() {
		const likeButtons = document.querySelectorAll<HTMLButtonElement>(
			'button[data-action="toggle-like"]',
		);
		if (!currentAuthState.isLoggedIn) {
			likeButtons.forEach((button) => {
				setLikeButtonState(button, false);
			});
			return;
		}

		try {
			const response = await fetch("/api/v1/me/article-likes/?limit=500", {
				credentials: "include",
			});
			const data = await response.json().catch(() => ({}));
			if (!response.ok || !data?.ok || !Array.isArray(data.items)) {
				return;
			}
			const likedArticleIds = new Set<string>(
				data.items
					.map((item: { article_id?: unknown }) =>
						item?.article_id ? String(item.article_id) : "",
					)
					.filter(Boolean),
			);
			likeButtons.forEach((button) => {
				const card = button.closest<HTMLElement>("[data-post-card]");
				const articleId = card?.dataset.articleId
					? String(card.dataset.articleId)
					: "";
				setLikeButtonState(button, likedArticleIds.has(articleId));
			});
		} catch (error) {
			console.error("[PostPage] failed to sync likes:", error);
		}
	}

	function removeCardByArticleId(articleId: string) {
		const card = document.querySelector<HTMLElement>(
			`[data-post-card][data-article-id="${CSS.escape(articleId)}"]`,
		);
		if (!card) {
			return;
		}
		const row = card.closest<HTMLElement>(".post-list-item");
		row?.remove();
	}

	function removeCardsByAuthorId(authorId: string) {
		const cards = document.querySelectorAll<HTMLElement>(
			`[data-post-card][data-author-id="${CSS.escape(authorId)}"]`,
		);
		cards.forEach((card) => {
			const row = card.closest<HTMLElement>(".post-list-item");
			row?.remove();
		});
	}

	async function requestDeleteArticle(articleId: string) {
		const response = await fetch(
			`/api/v1/me/articles/${encodeURIComponent(articleId)}/`,
			{
				method: "DELETE",
				credentials: "include",
			},
		);
		const data = await response.json().catch(() => ({}));
		if (!response.ok || !data?.ok) {
			throw new Error(data?.message || "删除失败");
		}
	}

	async function requestBlockUser(blockedUserId: string, reason?: string) {
		const response = await fetch("/api/v1/me/blocks/", {
			method: "POST",
			credentials: "include",
			headers: {
				"content-type": "application/json",
			},
			body: JSON.stringify({
				blocked_user_id: blockedUserId,
				reason: reason || undefined,
			}),
		});
		const data = await response.json().catch(() => ({}));
		if (!response.ok || !data?.ok) {
			throw new Error(data?.message || "屏蔽失败");
		}
	}

	async function requestReportArticle(input: {
		targetId: string;
		targetUserId: string;
		reason: string;
		detail?: string;
	}) {
		const response = await fetch("/api/v1/me/reports/", {
			method: "POST",
			credentials: "include",
			headers: {
				"content-type": "application/json",
			},
			body: JSON.stringify({
				target_type: "article",
				target_id: input.targetId,
				target_user_id: input.targetUserId || undefined,
				reason: input.reason,
				detail: input.detail || undefined,
			}),
		});
		const data = await response.json().catch(() => ({}));
		if (!response.ok || !data?.ok) {
			throw new Error(data?.message || "举报失败");
		}
	}

	async function requestToggleLike(articleId: string): Promise<{
		liked: boolean;
		like_count: number;
	}> {
		const response = await fetch("/api/v1/me/article-likes/", {
			method: "POST",
			credentials: "include",
			headers: {
				"content-type": "application/json",
			},
			body: JSON.stringify({
				article_id: articleId,
			}),
		});
		const data = await response.json().catch(() => ({}));
		if (!response.ok || !data?.ok) {
			throw new Error(data?.message || "点赞操作失败");
		}
		return {
			liked: Boolean(data.liked),
			like_count: Number(data.like_count || 0),
		};
	}

	function setupPostCardActions() {
		if (runtimeWindow._postCardActionsAttached) {
			return;
		}

		document.addEventListener("click", async (event) => {
			const target = event.target as HTMLElement | null;
			if (!target) {
				return;
			}
			const actionEl = target.closest<HTMLElement>("[data-action]");
			if (!actionEl) {
				return;
			}

			const card = actionEl.closest<HTMLElement>("[data-post-card]");
			if (!card) {
				return;
			}

			const action = String(actionEl.dataset.action || "");
			const articleId = String(card.dataset.articleId || "");
			const authorId = String(card.dataset.authorId || "");
			if (!articleId) {
				return;
			}

			if (!currentAuthState.isLoggedIn) {
				alert("请先登录后再操作。");
				return;
			}

			const details = actionEl.closest("details");
			details?.removeAttribute("open");

			try {
				if (action === "delete-article") {
					const canDelete =
						currentAuthState.isAdmin ||
						currentAuthState.userId === authorId;
					if (!canDelete) {
						alert("无权限删除该文章。");
						return;
					}
					if (!window.confirm("确认删除这篇文章？删除后不可恢复。")) {
						return;
					}
					await requestDeleteArticle(articleId);
					removeCardByArticleId(articleId);
					return;
				}

				if (action === "toggle-like") {
					const button = actionEl as HTMLButtonElement;
					const result = await requestToggleLike(articleId);
					setLikeButtonState(button, result.liked, result.like_count);
					return;
				}

				if (action === "block-user") {
					if (!authorId || currentAuthState.userId === authorId) {
						alert("不能屏蔽该用户。");
						return;
					}
					const reason = window.prompt("屏蔽原因（可选）：", "") || "";
					await requestBlockUser(authorId, reason);
					removeCardsByAuthorId(authorId);
					return;
				}

				if (action === "report-content") {
					const rawReason =
						window.prompt(
							"举报原因（spam/abuse/hate/violence/copyright/other）：",
							"other",
						) || "";
					if (!rawReason.trim()) {
						return;
					}
					const reason = rawReason.trim().toLowerCase();
					const normalizedReason = [
						"spam",
						"abuse",
						"hate",
						"violence",
						"copyright",
						"other",
					].includes(reason)
						? reason
						: "other";
					const detail = window.prompt("补充说明（可选）：", "") || "";
					await requestReportArticle({
						targetId: articleId,
						targetUserId: authorId,
						reason: normalizedReason,
						detail,
					});
					alert("已提交举报，我们会尽快处理。");
				}
			} catch (error) {
				const message =
					error instanceof Error ? error.message : "操作失败，请稍后重试。";
				alert(message);
			}
		});

		document.addEventListener("click", (event) => {
			const target = event.target as HTMLElement | null;
			if (!target) {
				return;
			}
			document
				.querySelectorAll<HTMLDetailsElement>(".post-card-menu[open]")
				.forEach((menu) => {
					if (!menu.contains(target)) {
						menu.removeAttribute("open");
					}
				});
		});

		document.addEventListener("mizuki:auth-state", async (event) => {
			const detail = (event as CustomEvent<Partial<AuthState>>).detail;
			updateCurrentAuthState({
				userId: detail?.userId ? String(detail.userId) : "",
				isAdmin: Boolean(detail?.isAdmin),
				isLoggedIn: Boolean(detail?.isLoggedIn),
			});
			updateCardActionVisibility(currentAuthState);
			await applyBlockedUsersFilter();
			await syncLikeButtons();
		});

		runtimeWindow._postCardActionsAttached = true;
	}

	setupCalendarFilterListeners();
	setupPostCardActions();
	updateCurrentAuthState(readCachedAuthState());
	updateCardActionVisibility(currentAuthState);
	void (async () => {
		await applyBlockedUsersFilter();
		await syncLikeButtons();
	})();
	</script>

<style>
	/* 基础容器 */
	#post-list-container {
		min-height: 200px;
		transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
	}

	/* 布局模式 - 列表模式 */
	#post-list-container.list-mode {
		@apply flex flex-col gap-4;
	}

	/* 内容可见性 (视口外不渲染) */
	#post-list-container > :global(*) {
		content-visibility: auto;
		contain-intrinsic-size: 200px;
		transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
		opacity: 0;
		animation: fadeInSlide 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
		animation-delay: calc(
			var(--content-delay) + var(--i) * var(--interval)
		);
	}

	@keyframes fadeInSlide {
		from {
			opacity: 0;
			transform: translateX(-10px);
		}
		to {
			opacity: 1;
			transform: translateX(0);
		}
	}
</style>
