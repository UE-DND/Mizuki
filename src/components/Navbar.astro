---
import { Icon } from "astro-icon/components";
import { getResolvedSiteSettings } from "@/server/site-settings/service";
import { LinkPresets } from "../constants/link-presets";
import type { LinkPreset } from "../types/config";
import { type NavBarLink } from "../types/config";
import { isAdminOnlyLink } from "../utils/nav-link-utils";
import { url } from "../utils/url-utils";
import LightDarkSwitch from "./LightDarkSwitch.svelte";
import AuthStatus from "./auth/AuthStatus.astro";
import DropdownMenu from "./widget/DropdownMenu.astro";

const className = Astro.props.class;
const resolvedSiteSettings =
  Astro.locals.siteSettings ?? (await getResolvedSiteSettings());
const siteSettings = resolvedSiteSettings.settings;
const navBarConfig = siteSettings.navBar;

const DEFAULT_NAV_ICON = "/assets/home/home.png";

function resolveAssetSrc(path: string): string {
  return path.startsWith("/") ? url(path) : path;
}

const navbarIconSrc =
  siteSettings.site.favicon[0]?.src ||
  siteSettings.navbarTitle?.icon ||
  DEFAULT_NAV_ICON;

const navbarTransparentMode =
  siteSettings.banner?.navbar?.transparentMode || "semi";
const isHomePage = Astro.url.pathname === "/" || Astro.url.pathname === "";

function resolveLink(link: NavBarLink | LinkPreset): NavBarLink {
  if (typeof link === "number") {
    return LinkPresets[link];
  }
  return link;
}

function withoutAdminChildren(link: NavBarLink): NavBarLink | null {
  if (isAdminOnlyLink(link)) {
    return null;
  }
  const childrenSource = Array.isArray(link.children) ? link.children : [];
  if (childrenSource.length === 0) {
    return link;
  }
  const children = childrenSource
    .map((child) => resolveLink(child))
    .filter((child) => !isAdminOnlyLink(child));
  if (children.length === 0) {
    const rawUrl = String(link.url || "").trim();
    if (!rawUrl || rawUrl === "#") {
      return null;
    }
  }
  return { ...link, children };
}

const links: NavBarLink[] = navBarConfig.links
  .map((item) => resolveLink(item))
  .map((item) => withoutAdminChildren(item))
  .filter((item): item is NavBarLink => Boolean(item));
---

<div
  id="navbar"
  class="z-50 onload-animation group"
  data-transparent-mode={navbarTransparentMode}
  data-is-home={isHomePage}
>
  <div
    class="navbar-bg-strip absolute h-8 left-0 right-0 -top-8 bg-(--card-bg) transition"
  >
  </div>
  <div
    class:list={[
      className,
      "navbar-shell overflow-visible! w-full min-w-0 max-w-(--page-width) h-[4.5rem] mx-auto flex items-center justify-between px-4",
    ]}
  >
    <a
      id="navbar-logo"
      href={url("/")}
      class="btn-plain scale-animation rounded-lg h-[3.25rem] in-[.enable-banner]:!h-[2.5rem] in-[.enable-banner]:group-[.scrolled]:!h-[3.25rem] px-5 font-bold active:scale-95 min-w-0 max-w-none transition-all duration-920"
    >
      <div class="flex flex-row items-center min-w-0 text-md">
        {
          siteSettings.navbarTitle ? (
            siteSettings.navbarTitle.mode === "logo" ? (
              <img
                src={url(
                  siteSettings.navbarTitle.logo ||
                    "/assets/home/default-logo.png",
                )}
                alt={siteSettings.navbarTitle.text}
                class="h-[3.25rem] in-[.enable-banner]:!h-[2.5rem] in-[.enable-banner]:group-[.scrolled]:!h-[3.25rem] max-w-full object-contain transition-all duration-920"
                loading="lazy"
              />
            ) : (
              <>
                <img
                  src={resolveAssetSrc(navbarIconSrc)}
                  alt={siteSettings.navbarTitle.text}
                  class="h-[1.75rem] w-[1.75rem] mr-2 object-contain"
                  loading="lazy"
                />
                <span class="max-w-none truncate dark:text-white text-black">
                  {siteSettings.navbarTitle.text}
                </span>
              </>
            )
          ) : (
            <>
              <Icon
                name="material-symbols:home-pin-outline"
                class="text-[1.75rem] mr-2"
              />
              <span class="max-w-none truncate dark:text-white text-black">
                {siteSettings.site.title}
              </span>
            </>
          )
        }
      </div>
    </a>

    <div
      id="navbar-links-container"
      class="flex items-center space-x-1 transition-opacity duration-300"
    >
      {
        links.map((l) => {
          return <DropdownMenu link={l} />;
        })
      }
    </div>

    <div class="flex shrink-0 items-center gap-1">
      <LightDarkSwitch client:only="svelte" />
      <AuthStatus />
    </div>
  </div>
</div>

<script>
  import {
    emitAuthState,
    getAuthState,
    subscribeAuthState,
    type AuthState,
  } from "@/scripts/auth-state";
  import { showAuthRequiredDialog } from "@/scripts/dialogs";

  const navbarLinksContainer = document.getElementById(
    "navbar-links-container",
  );
  const AUTH_PROTECTED_TARGET_ATTR = "data-auth-target-href";

  const setAuthProtectedLink = (
    anchor: HTMLAnchorElement,
    targetHref: string,
    options?: {
      keepNoSwup?: boolean;
    },
  ): void => {
    anchor.setAttribute(AUTH_PROTECTED_TARGET_ATTR, targetHref);
    anchor.setAttribute("href", "#");
    anchor.setAttribute("data-needs-login", "");
    if (options?.keepNoSwup) {
      anchor.setAttribute("data-no-swup", "");
    } else {
      anchor.removeAttribute("data-no-swup");
    }
  };

  const clearAuthProtectedLink = (
    anchor: HTMLAnchorElement,
    href: string,
    options?: {
      removeNoSwup?: boolean;
    },
  ): void => {
    anchor.setAttribute("href", href);
    anchor.removeAttribute("data-needs-login");
    anchor.removeAttribute(AUTH_PROTECTED_TARGET_ATTR);
    if (options?.removeNoSwup) {
      anchor.removeAttribute("data-no-swup");
    }
  };

  const updateUserRouteLinks = (
    username: string,
    isLoggedIn: boolean,
  ): void => {
    const cleanUsername = String(username || "").trim();
    const anchors = Array.from(
      document.querySelectorAll<HTMLAnchorElement>("a[href]"),
    );
    anchors.forEach((anchor) => {
      const rawHref = anchor.getAttribute("href") || "";
      const targetHref =
        anchor.getAttribute(AUTH_PROTECTED_TARGET_ATTR) || rawHref;
      if (!targetHref.startsWith("/")) return;
      let pathname = targetHref;
      let search = "";
      let hash = "";
      try {
        const parsed = new URL(targetHref, window.location.origin);
        pathname = parsed.pathname;
        search = parsed.search;
        hash = parsed.hash;
      } catch {
        // noop: keep rawHref fallback
      }

      if (pathname === "/publish") {
        const publishHref = `${pathname}${search}${hash}`;
        if (isLoggedIn) {
          clearAuthProtectedLink(anchor, publishHref, {
            removeNoSwup: true,
          });
        } else {
          setAuthProtectedLink(anchor, publishHref, {
            keepNoSwup: true,
          });
        }
        return;
      }

      const hasUserPlaceholder = pathname
        .split("/")
        .filter(Boolean)
        .includes("__user__");

      if (hasUserPlaceholder) {
        if (cleanUsername) {
          const resolvedPath = `/${pathname
            .split("/")
            .filter(Boolean)
            .map((segment) =>
              segment === "__user__" ? cleanUsername : segment,
            )
            .join("/")}`;
          clearAuthProtectedLink(anchor, `${resolvedPath}${search}${hash}`);
        } else if (!isLoggedIn) {
          setAuthProtectedLink(anchor, `${pathname}${search}${hash}`);
        } else {
          clearAuthProtectedLink(anchor, "/me");
        }
        return;
      }
      let hashLower = "";
      try {
        const parsed = new URL(targetHref, window.location.origin);
        pathname = parsed.pathname;
        hashLower = parsed.hash.replace(/^#/, "").trim().toLowerCase();
      } catch {
        pathname = targetHref;
      }
      if (pathname === "/me") {
        if (
          hashLower === "anime" ||
          hashLower === "diary" ||
          hashLower === "albums"
        ) {
          if (cleanUsername) {
            clearAuthProtectedLink(anchor, `/${cleanUsername}/${hashLower}`);
          } else if (!isLoggedIn) {
            setAuthProtectedLink(anchor, `${pathname}${search}${hash}`);
          } else {
            clearAuthProtectedLink(anchor, "/me");
          }
        }
        return;
      }
      const legacyTarget = ["/anime", "/diary", "/albums"];
      if (!legacyTarget.includes(pathname)) return;
      const target = pathname.replace(/^\//, "");
      if (cleanUsername) {
        clearAuthProtectedLink(anchor, `/${cleanUsername}/${target}`);
      } else if (!isLoggedIn) {
        setAuthProtectedLink(anchor, `/${target}`);
      } else {
        clearAuthProtectedLink(anchor, "/me");
      }
    });
  };

  const fetchAuthProfile = async () => {
    try {
      const response = await fetch("/api/auth/me", {
        method: "GET",
        credentials: "include",
        headers: { Accept: "application/json" },
        cache: "no-store",
      });
      const data = await response.json().catch(() => null);
      if (!response.ok || !data?.ok) {
        return { ok: false, username: "", isAdmin: false, userId: "" };
      }
      return {
        ok: true,
        username: String(data?.user?.username || "").trim(),
        isAdmin: Boolean(data?.is_admin || data?.isAdmin),
        userId: String(data?.user?.id || "").trim(),
      };
    } catch (error) {
      console.warn("[navbar] failed to load username:", error);
      return { ok: false, username: "", isAdmin: false, userId: "" };
    }
  };

  const applyAuthRouting = async (
    state: AuthState | null | undefined,
  ): Promise<void> => {
    let username = String(state?.username || "").trim();
    let isLoggedIn = Boolean(state?.isLoggedIn);

    // 先使用当前已知状态立即更新链接行为，避免等待鉴权接口期间出现竞态
    updateUserRouteLinks(username, isLoggedIn);

    if (!username) {
      const profile = await fetchAuthProfile();
      if (profile.ok) {
        username = profile.username;
        isLoggedIn = true;
        emitAuthState({
          isLoggedIn: true,
          isAdmin: profile.isAdmin,
          userId: profile.userId,
          username,
        });
      }
    }
    updateUserRouteLinks(username, isLoggedIn);
  };

  const initialAuth = getAuthState();
  applyAuthRouting(initialAuth);
  subscribeAuthState((state) => {
    applyAuthRouting(state);
  });

  document.addEventListener("astro:after-swap", () => {
    applyAuthRouting(getAuthState());
  });

  document.addEventListener(
    "click",
    (e) => {
      const target = e.target;
      if (!(target instanceof Element)) {
        return;
      }
      const anchor = target.closest<HTMLAnchorElement>("a[href]");
      if (!anchor) {
        return;
      }
      if (
        e.defaultPrevented ||
        e.button !== 0 ||
        e.metaKey ||
        e.ctrlKey ||
        e.shiftKey ||
        e.altKey
      ) {
        return;
      }

      const rawHref = anchor.getAttribute("href") || "";
      const needsLogin = anchor.hasAttribute("data-needs-login");
      const authTargetHref =
        anchor.getAttribute(AUTH_PROTECTED_TARGET_ATTR) || rawHref;
      const isPublishTarget = (() => {
        if (!authTargetHref.startsWith("/")) {
          return false;
        }
        try {
          const parsed = new URL(authTargetHref, window.location.origin);
          return parsed.pathname === "/publish";
        } catch {
          return false;
        }
      })();

      if (isPublishTarget && !getAuthState().isLoggedIn) {
        e.preventDefault();
        e.stopImmediatePropagation();
        showAuthRequiredDialog();
        return;
      }

      if (needsLogin) {
        e.preventDefault();
        e.stopImmediatePropagation();
        showAuthRequiredDialog();
      }
    },
    true,
  );

  if (navbarLinksContainer) {
    navbarLinksContainer.style.opacity = "1";
  }
</script>
