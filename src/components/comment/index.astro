---
import { Icon } from "astro-icon/components";
import "../../styles/markdown.css";
import "../../styles/markdown-extend.styl";

interface Props {
  module?: "articles" | "diaries";
  contentId?: string;
  allowComments?: boolean;
}

const moduleName = Astro.props.module;
const contentId = Astro.props.contentId;
const enabled =
  typeof Astro.props.allowComments === "boolean"
    ? Astro.props.allowComments
    : true;

const hasDirectusTarget = Boolean(moduleName && contentId);
---

{
  enabled && (
    <div
      class="card-base p-6 mb-4 relative overflow-visible"
      id="directus-comment-root"
      data-module={moduleName || ""}
      data-content-id={contentId || ""}
      data-directus-enabled={hasDirectusTarget ? "1" : "0"}
    >
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-xl font-semibold text-90">评论</h3>
      </div>

      {!hasDirectusTarget && (
        <p class="text-sm text-70 rounded-xl border border-(--line-divider) px-4 py-3">
          旧评论系统已移除。该页面未绑定 Directus 评论对象。
        </p>
      )}

      {hasDirectusTarget && (
        <>
          <form id="comment-create-form" class="space-y-3 mb-6">
            <input type="hidden" id="comment-parent-id" value="" />

            <div class="flex items-center gap-2">
              <button
                type="button"
                id="comment-mode-edit"
                class="px-3 py-1.5 rounded-lg text-xs border border-(--line-divider) text-60"
                aria-pressed="true"
              >
                编辑
              </button>
              <button
                type="button"
                id="comment-mode-preview"
                class="px-3 py-1.5 rounded-lg text-xs border border-(--line-divider) text-60"
                aria-pressed="false"
              >
                预览
              </button>
            </div>

            <div id="comment-editor-panel" class="space-y-3">
              <textarea
                id="comment-body"
                rows="6"
                class="w-full rounded-xl border border-(--line-divider) bg-transparent px-4 py-3 text-90 font-mono focus:outline-none focus:border-(--primary)"
                placeholder="期待你的神评..."
              />

              <div class="flex w-full items-center gap-2">
                <div
                  id="comment-toolbar"
                  class="flex flex-nowrap items-center gap-2 overflow-x-auto min-w-0 pr-1"
                >
                  <button
                    type="button"
                    class="comment-toolbar-btn btn-plain scale-animation w-9 h-9 rounded-lg border border-(--line-divider) text-75 hover:text-90"
                    data-md-action="bold"
                    aria-label="加粗"
                    title="加粗"
                  >
                    <Icon
                      name="material-symbols:format-bold"
                      class="text-[1.1rem]"
                    />
                  </button>
                  <button
                    type="button"
                    class="comment-toolbar-btn btn-plain scale-animation w-9 h-9 rounded-lg border border-(--line-divider) text-75 hover:text-90"
                    data-md-action="italic"
                    aria-label="斜体"
                    title="斜体"
                  >
                    <Icon
                      name="material-symbols:format-italic"
                      class="text-[1.1rem]"
                    />
                  </button>
                  <button
                    type="button"
                    class="comment-toolbar-btn btn-plain scale-animation w-9 h-9 rounded-lg border border-(--line-divider) text-75 hover:text-90"
                    data-md-action="underline"
                    aria-label="下划线"
                    title="下划线"
                  >
                    <Icon
                      name="material-symbols:format-underlined"
                      class="text-[1.1rem]"
                    />
                  </button>
                  <button
                    type="button"
                    class="comment-toolbar-btn btn-plain scale-animation w-9 h-9 rounded-lg border border-(--line-divider) text-75 hover:text-90"
                    data-md-action="strike"
                    aria-label="删除线"
                    title="删除线"
                  >
                    <Icon
                      name="material-symbols:format-strikethrough"
                      class="text-[1.1rem]"
                    />
                  </button>
                  <button
                    type="button"
                    class="comment-toolbar-btn btn-plain scale-animation w-9 h-9 rounded-lg border border-(--line-divider) text-75 hover:text-90"
                    data-md-action="quote"
                    aria-label="引用"
                    title="引用"
                  >
                    <Icon
                      name="material-symbols:format-quote"
                      class="text-[1.1rem]"
                    />
                  </button>
                  <button
                    type="button"
                    class="comment-toolbar-btn btn-plain scale-animation w-9 h-9 rounded-lg border border-(--line-divider) text-75 hover:text-90"
                    data-md-action="inline-code"
                    aria-label="行内代码"
                    title="行内代码"
                  >
                    <Icon name="material-symbols:code" class="text-[1.1rem]" />
                  </button>
                  <button
                    type="button"
                    class="comment-toolbar-btn btn-plain scale-animation w-9 h-9 rounded-lg border border-(--line-divider) text-75 hover:text-90"
                    data-md-action="code-block"
                    aria-label="代码块"
                    title="代码块"
                  >
                    <Icon
                      name="material-symbols:terminal"
                      class="text-[1.1rem]"
                    />
                  </button>
                </div>
                <button
                  type="submit"
                  id="comment-submit"
                  class="ml-auto shrink-0 px-4 py-2 rounded-lg bg-(--btn-regular-bg) text-(--btn-content) text-sm"
                >
                  发布评论
                </button>
              </div>
            </div>

            <div
              id="comment-preview-panel"
              class="hidden rounded-xl border border-(--line-divider) p-4"
            >
              <div id="comment-preview-loading" class="hidden text-xs text-60">
                预览渲染中喵...
              </div>
              <p
                id="comment-preview-error"
                class="hidden text-sm text-red-500"
              />
              <div id="comment-preview-empty" class="text-sm text-60">
                暂无预览内容喵～
              </div>
              <div
                id="comment-preview-content"
                class="hidden prose prose-sm md:prose-base dark:prose-invert !max-w-none custom-md text-90"
              />
            </div>

            <div class="flex items-center justify-between gap-2">
              <div class="text-xs text-60" id="comment-reply-hint" />
              <div class="flex items-center gap-2">
                <button
                  type="button"
                  id="comment-reply-cancel"
                  class="hidden px-3 py-2 rounded-lg border border-(--line-divider) text-xs text-75"
                >
                  取消回复
                </button>
              </div>
            </div>
            <p id="comment-form-error" class="hidden text-sm text-red-500" />
          </form>

          <div id="comment-list" class="space-y-4" />
          <div
            id="comment-empty"
            class="hidden text-sm text-60 rounded-xl border border-(--line-divider) px-4 py-3"
          >
            暂无评论，来抢沙发吧。
          </div>
        </>
      )}
    </div>
  )
}

<script>
  import { getAuthState, subscribeAuthState } from "@/scripts/auth-state";
  import type { AuthState } from "@/scripts/auth-state";
  import { setupCodeCopyDelegation } from "@/scripts/code-copy";
  import {
    showAuthRequiredDialog,
    showConfirmDialog,
    showNoticeDialog,
  } from "@/scripts/dialogs";
  import { refreshGithubCards } from "@/scripts/github-card-runtime";

  type CommentAuthor = {
    name?: string | null;
    display_name?: string | null;
    username?: string | null;
    avatar_url?: string | null;
  };

  type CommentItem = {
    id: string;
    author_id?: string | null;
    author?: CommentAuthor | null;
    date_created?: string | null;
    body?: string | null;
    body_html?: string | null;
    replies?: CommentItem[] | null;
  };

  type CommentMode = "edit" | "preview";
  type CommentToolbarAction =
    | "bold"
    | "italic"
    | "underline"
    | "strike"
    | "quote"
    | "inline-code"
    | "code-block";

  const TOOLBAR_ACTIONS = new Set<CommentToolbarAction>([
    "bold",
    "italic",
    "underline",
    "strike",
    "quote",
    "inline-code",
    "code-block",
  ]);

  const runtimeWindow = window as Window &
    typeof globalThis & {
      _directusCommentAuthSubscribed?: boolean;
      _directusCommentApplyAuth?: (state: AuthState) => void;
      _directusCommentMenuOutsideBound?: boolean;
      renderMermaidDiagrams?: () => Promise<void>;
      codeBlockCollapser?: {
        setupCodeBlocks?: () => void;
        toggleCollapse?: (element: Element) => void;
      };
    };

  function initComments() {
    const root = document.getElementById("directus-comment-root");
    if (!root) return;

    const moduleName = String(root.dataset.module || "").trim();
    const contentId = String(root.dataset.contentId || "").trim();
    const directusEnabled = root.dataset.directusEnabled === "1";

    const commentListEl = document.getElementById("comment-list");
    const commentEmptyEl = document.getElementById("comment-empty");
    const formEl = document.getElementById(
      "comment-create-form",
    ) as HTMLFormElement | null;
    const bodyEl = document.getElementById(
      "comment-body",
    ) as HTMLTextAreaElement | null;
    const toolbarEl = document.getElementById("comment-toolbar");
    const editorPanelEl = document.getElementById("comment-editor-panel");
    const previewPanelEl = document.getElementById("comment-preview-panel");
    const modeEditEl = document.getElementById(
      "comment-mode-edit",
    ) as HTMLButtonElement | null;
    const modePreviewEl = document.getElementById(
      "comment-mode-preview",
    ) as HTMLButtonElement | null;
    const previewLoadingEl = document.getElementById("comment-preview-loading");
    const previewErrorEl = document.getElementById("comment-preview-error");
    const previewEmptyEl = document.getElementById("comment-preview-empty");
    const previewContentEl = document.getElementById("comment-preview-content");
    const parentIdEl = document.getElementById(
      "comment-parent-id",
    ) as HTMLInputElement | null;
    const submitEl = document.getElementById(
      "comment-submit",
    ) as HTMLButtonElement | null;
    const formErrorEl = document.getElementById("comment-form-error");
    const replyHintEl = document.getElementById("comment-reply-hint");
    const replyCancelEl = document.getElementById("comment-reply-cancel");

    let currentUserId = "";
    let isAdmin = false;
    let comments: CommentItem[] = [];
    let commentMode: CommentMode = "edit";
    let previewSource = "";
    let previewHtml = "";
    let previewError = "";
    let previewLoading = false;
    let previewDirty = false;
    let previewRequestId = 0;
    let renderedPreviewHtml = "";

    const escapeHtml = (raw: unknown): string =>
      String(raw || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");

    const formatDate = (iso: string | null | undefined): string => {
      if (!iso) return "";
      const time = new Date(iso);
      if (Number.isNaN(time.getTime())) return "";
      return time.toLocaleString();
    };

    const getAuthorName = (
      author: CommentAuthor | null | undefined,
    ): string => {
      const displayName = String(author?.display_name || "").trim();
      if (displayName) {
        return displayName;
      }
      return String(author?.name || "").trim() || "匿名用户";
    };

    const getAuthorProfileHref = (
      author: CommentAuthor | null | undefined,
    ): string | null => {
      const username = String(author?.username || "").trim();
      if (!username) {
        return null;
      }
      return `/${encodeURIComponent(username)}`;
    };

    const isToolbarAction = (value: string): value is CommentToolbarAction => {
      return TOOLBAR_ACTIONS.has(value as CommentToolbarAction);
    };

    const commentApiBase = (): string => {
      if (moduleName === "diaries") {
        return `/api/v1/diaries/${encodeURIComponent(contentId)}/comments`;
      }
      return `/api/v1/articles/${encodeURIComponent(contentId)}/comments`;
    };

    const commentItemApi = (commentId: string): string => {
      if (moduleName === "diaries") {
        return `/api/v1/diaries/comments/${encodeURIComponent(commentId)}`;
      }
      return `/api/v1/articles/comments/${encodeURIComponent(commentId)}`;
    };

    const commentPreviewApi = (): string => {
      if (moduleName === "diaries") {
        return "/api/v1/diaries/comments/preview";
      }
      return "/api/v1/articles/comments/preview";
    };

    const hasHtmlTag = (value: string): boolean => {
      return /<[a-z][\w:-]*(\s[^>]*)?>/i.test(value);
    };

    const decodeHtmlEntities = (value: string): string => {
      const textarea = document.createElement("textarea");
      textarea.innerHTML = value;
      return String(textarea.value || "");
    };

    const normalizeMarkdownHtml = (raw: unknown): string => {
      const source = String(raw || "").trim();
      if (!source) {
        return "";
      }
      if (hasHtmlTag(source)) {
        return source;
      }
      if (source.includes("&lt;") || source.includes("&#")) {
        const decoded = decodeHtmlEntities(source).trim();
        if (hasHtmlTag(decoded)) {
          return decoded;
        }
      }
      return source;
    };

    const resolveBodyHtmlFromResponse = (data: unknown): string => {
      if (!data || typeof data !== "object") {
        return "";
      }
      const record = data as Record<string, unknown>;
      const item =
        record.item && typeof record.item === "object"
          ? (record.item as Record<string, unknown>)
          : null;
      return normalizeMarkdownHtml(record.body_html ?? item?.body_html ?? "");
    };

    const refreshMarkdownRuntime = async (): Promise<void> => {
      setupCodeCopyDelegation();
      try {
        await refreshGithubCards();
      } catch (error) {
        console.warn("[comment] refresh github cards failed:", error);
      }
      if (typeof runtimeWindow.renderMermaidDiagrams === "function") {
        void runtimeWindow.renderMermaidDiagrams().catch((error) => {
          console.warn("[comment] refresh mermaid failed:", error);
        });
      }
    };

    const collapseCommentCodeBlocks = (): void => {
      runtimeWindow.codeBlockCollapser?.setupCodeBlocks?.();

      const collapseNow = (): void => {
        const commentCodeBlocks = root.querySelectorAll<HTMLElement>(
          ".expressive-code.collapsible",
        );
        commentCodeBlocks.forEach((block) => {
          if (block.dataset.commentDefaultCollapsed === "1") {
            return;
          }
          const isCollapsed = block.classList.contains("collapsed");
          if (!isCollapsed) {
            if (runtimeWindow.codeBlockCollapser?.toggleCollapse) {
              runtimeWindow.codeBlockCollapser.toggleCollapse(block);
            } else {
              block.classList.remove("expanded");
              block.classList.add("collapsed");
            }
          }
          block.dataset.commentDefaultCollapsed = "1";
        });
      };

      requestAnimationFrame(() => {
        collapseNow();
        setTimeout(collapseNow, 80);
      });
    };

    const closeAllCommentActionMenus = (): void => {
      const openedMenus = document.querySelectorAll<HTMLDetailsElement>(
        "details.comment-action-menu[open]",
      );
      openedMenus.forEach((menu) => {
        menu.removeAttribute("open");
      });
    };

    const setFormError = (message: string): void => {
      if (!formErrorEl) return;
      if (!message) {
        formErrorEl.classList.add("hidden");
        formErrorEl.textContent = "";
        return;
      }
      formErrorEl.textContent = message;
      formErrorEl.classList.remove("hidden");
    };

    const setReplyState = (parentId: string, authorName: string): void => {
      if (!parentIdEl || !replyHintEl || !replyCancelEl) return;
      parentIdEl.value = parentId || "";
      if (parentId) {
        replyHintEl.textContent = `正在回复 ${authorName || "该用户"}`;
        replyCancelEl.classList.remove("hidden");
      } else {
        replyHintEl.textContent = "";
        replyCancelEl.classList.add("hidden");
      }
    };

    const updateModeButtonStyle = (
      button: HTMLButtonElement | null,
      active: boolean,
    ): void => {
      if (!button) return;
      button.setAttribute("aria-pressed", active ? "true" : "false");
      button.classList.toggle("text-90", active);
      button.classList.toggle("text-60", !active);
      button.classList.toggle("bg-(--btn-plain-bg-hover)", active);
      button.classList.toggle("border-(--primary)", active);
    };

    const renderPreview = (): void => {
      if (
        !previewLoadingEl ||
        !previewErrorEl ||
        !previewEmptyEl ||
        !previewContentEl
      ) {
        return;
      }

      previewLoadingEl.classList.toggle("hidden", !previewLoading);

      if (previewError) {
        previewErrorEl.textContent = previewError;
        previewErrorEl.classList.remove("hidden");
      } else {
        previewErrorEl.textContent = "";
        previewErrorEl.classList.add("hidden");
      }

      if (previewHtml) {
        if (renderedPreviewHtml !== previewHtml) {
          previewContentEl.innerHTML = previewHtml;
          renderedPreviewHtml = previewHtml;
          void refreshMarkdownRuntime();
          collapseCommentCodeBlocks();
        }
        previewContentEl.classList.remove("hidden");
        previewEmptyEl.classList.add("hidden");
        return;
      }

      previewContentEl.innerHTML = "";
      renderedPreviewHtml = "";
      previewContentEl.classList.add("hidden");
      previewEmptyEl.classList.remove("hidden");
    };

    const setCommentMode = (mode: CommentMode): void => {
      commentMode = mode;
      if (editorPanelEl) {
        editorPanelEl.classList.toggle("hidden", mode !== "edit");
      }
      if (previewPanelEl) {
        previewPanelEl.classList.toggle("hidden", mode !== "preview");
      }
      updateModeButtonStyle(modeEditEl, mode === "edit");
      updateModeButtonStyle(modePreviewEl, mode === "preview");
      if (mode === "preview") {
        void requestPreview();
      }
    };

    const markPreviewDirty = (): void => {
      previewDirty = true;
    };

    const replaceSelection = (
      textarea: HTMLTextAreaElement,
      replacement: string,
      selectionStartOffset: number,
      selectionEndOffset: number,
    ): void => {
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const source = textarea.value;
      const before = source.slice(0, start);
      const after = source.slice(end);
      textarea.value = `${before}${replacement}${after}`;
      const nextStart = before.length + selectionStartOffset;
      const nextEnd = before.length + selectionEndOffset;
      textarea.focus();
      textarea.setSelectionRange(nextStart, nextEnd);
      markPreviewDirty();
    };

    const applyWrapAction = (
      textarea: HTMLTextAreaElement,
      prefix: string,
      suffix: string,
      placeholder: string,
    ): void => {
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const selected = textarea.value.slice(start, end);
      const content = selected || placeholder;
      const replacement = `${prefix}${content}${suffix}`;
      const selectionStartOffset = prefix.length;
      const selectionEndOffset = prefix.length + content.length;
      replaceSelection(
        textarea,
        replacement,
        selectionStartOffset,
        selectionEndOffset,
      );
    };

    const applyQuoteAction = (textarea: HTMLTextAreaElement): void => {
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const selected = textarea.value.slice(start, end);
      const source = selected || "引用内容";
      const quoted = source
        .replaceAll("\r\n", "\n")
        .split("\n")
        .map((line) => (line.startsWith("> ") ? line : `> ${line}`))
        .join("\n");
      replaceSelection(textarea, quoted, 0, quoted.length);
    };

    const applyCodeBlockAction = (textarea: HTMLTextAreaElement): void => {
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const source = textarea.value;
      const selected = source.slice(start, end) || "代码内容";
      const language = "text";
      const block = `\`\`\`${language}\n${selected}\n\`\`\``;
      const needsLeadingBreak = start > 0 && source[start - 1] !== "\n";
      const needsTrailingBreak = end < source.length && source[end] !== "\n";
      const prefix = needsLeadingBreak ? "\n" : "";
      const suffix = needsTrailingBreak ? "\n" : "";
      const replacement = `${prefix}${block}${suffix}`;
      const contentStartOffset = prefix.length + `\`\`\`${language}\n`.length;
      const contentEndOffset = contentStartOffset + selected.length;
      replaceSelection(
        textarea,
        replacement,
        contentStartOffset,
        contentEndOffset,
      );
    };

    const applyToolbarAction = (action: CommentToolbarAction): void => {
      if (!bodyEl) return;
      if (action === "bold") {
        applyWrapAction(bodyEl, "**", "**", "粗体文本");
        return;
      }
      if (action === "italic") {
        applyWrapAction(bodyEl, "*", "*", "斜体文本");
        return;
      }
      if (action === "underline") {
        applyWrapAction(bodyEl, "<u>", "</u>", "下划线文本");
        return;
      }
      if (action === "strike") {
        applyWrapAction(bodyEl, "~~", "~~", "删除线文本");
        return;
      }
      if (action === "quote") {
        applyQuoteAction(bodyEl);
        return;
      }
      if (action === "inline-code") {
        applyWrapAction(bodyEl, "`", "`", "代码");
        return;
      }
      if (action === "code-block") {
        applyCodeBlockAction(bodyEl);
      }
    };

    const requestPreview = async (force = false): Promise<void> => {
      if (!bodyEl) return;
      const source = String(bodyEl.value || "");
      const text = source.trim();
      if (!force && !previewDirty && source === previewSource) {
        return;
      }

      if (!text) {
        previewSource = source;
        previewHtml = "";
        previewError = "";
        previewLoading = false;
        previewDirty = false;
        renderPreview();
        return;
      }

      if (!currentUserId) {
        previewSource = source;
        previewHtml = "";
        previewError = "请先登录后预览评论内容。";
        previewLoading = false;
        previewDirty = false;
        renderPreview();
        return;
      }

      previewLoading = true;
      previewError = "";
      renderPreview();

      const requestId = ++previewRequestId;
      try {
        const response = await fetch(commentPreviewApi(), {
          method: "POST",
          credentials: "include",
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
          },
          body: JSON.stringify({ body: text }),
        });
        const data = await response.json().catch(() => null);
        if (requestId !== previewRequestId) {
          return;
        }
        if (!response.ok || !data?.ok) {
          previewHtml = "";
          previewError = data?.message || "预览生成失败";
          previewDirty = true;
          return;
        }
        previewHtml = resolveBodyHtmlFromResponse(data);
        previewSource = source;
        previewError = "";
        previewDirty = false;
      } catch (error) {
        console.error("[comment] preview render failed:", error);
        if (requestId !== previewRequestId) {
          return;
        }
        previewHtml = "";
        previewError = "预览生成失败，请稍后重试";
        previewDirty = true;
      } finally {
        if (requestId === previewRequestId) {
          previewLoading = false;
          renderPreview();
        }
      }
    };

    const canDeleteComment = (item: CommentItem): boolean => {
      return (
        Boolean(currentUserId) &&
        Boolean(item) &&
        (item.author_id === currentUserId || isAdmin)
      );
    };

    const renderCommentActions = (item: CommentItem, level: number): string => {
      const canReply = level === 0;
      const canDelete = canDeleteComment(item);
      if (!canReply && !canDelete) return "";

      const menuActions: string[] = [];
      if (canReply) {
        menuActions.push(
          `<button type="button" class="comment-action w-full text-left px-3 py-2 rounded-lg text-sm hover:bg-black/5 dark:hover:bg-white/10" data-action="reply" data-id="${escapeHtml(item.id)}" data-author="${escapeHtml(item.author?.name || "用户")}">回复</button>`,
        );
      }
      if (canDelete) {
        menuActions.push(
          `<button type="button" class="comment-action w-full text-left px-3 py-2 rounded-lg text-sm text-red-500 hover:bg-black/5 dark:hover:bg-white/10" data-action="delete" data-id="${escapeHtml(item.id)}">删除</button>`,
        );
      }

      return `
				<details class="relative comment-action-menu z-20">
						<summary class="list-none cursor-pointer btn-plain scale-animation w-8 h-8 rounded-lg flex items-center justify-center text-base select-none text-75" aria-label="评论操作">...</summary>
						<div class="absolute right-0 top-9 z-50 min-w-[7rem] card-base rounded-xl border border-(--line-divider) p-2 text-90">
						${menuActions.join("")}
					</div>
				</details>
			`;
    };

    const renderCommentBody = (item: CommentItem): string => {
      const bodyHtml = normalizeMarkdownHtml(item.body_html);
      if (bodyHtml) {
        return `<div class="prose prose-sm md:prose-base dark:prose-invert !max-w-none custom-md text-90">${bodyHtml}</div>`;
      }
      return `<div class="text-sm leading-7 whitespace-pre-wrap break-words text-90">${escapeHtml(item.body || "")}</div>`;
    };

    const renderCommentNode = (item: CommentItem, level: number): string => {
      const authorName = getAuthorName(item.author);
      const authorHref = getAuthorProfileHref(item.author);
      const avatarContent = item.author?.avatar_url
        ? `<img src="${escapeHtml(item.author.avatar_url)}" alt="用户头像" class="w-8 h-8 rounded-full object-cover" loading="lazy" />`
        : `<div class="w-8 h-8 rounded-full bg-black/10 dark:bg-white/10"></div>`;
      const avatar = authorHref
        ? `<a href="${escapeHtml(authorHref)}" class="block rounded-full hover:opacity-90 transition-opacity">${avatarContent}</a>`
        : avatarContent;
      const authorNameHtml = authorHref
        ? `<a href="${escapeHtml(authorHref)}" class="truncate text-90 hover:text-(--primary) transition-colors">${escapeHtml(authorName)}</a>`
        : `<span class="truncate text-90">${escapeHtml(authorName)}</span>`;
      const replies = Array.isArray(item.replies) ? item.replies : [];

      return `
				<div class="comment-node ${level > 0 ? "ml-8 mt-3" : ""}" data-comment-id="${escapeHtml(item.id)}">
					<div class="rounded-xl border border-(--line-divider) p-4 space-y-3 text-90">
						<div class="flex items-start justify-between gap-3">
							<div class="flex items-center gap-3 min-w-0">
								${avatar}
								<div class="min-w-0">
									<div class="text-sm font-medium">${authorNameHtml}</div>
									<div class="text-xs text-60">${escapeHtml(formatDate(item.date_created))}</div>
								</div>
							</div>
							${renderCommentActions(item, level)}
						</div>
						${renderCommentBody(item)}
					</div>
					<div class="space-y-2">${replies
            .map((reply: CommentItem) => renderCommentNode(reply, 1))
            .join("")}</div>
				</div>
			`;
    };

    const renderComments = (): void => {
      if (!commentListEl || !commentEmptyEl) return;
      if (!Array.isArray(comments) || comments.length === 0) {
        commentListEl.innerHTML = "";
        commentEmptyEl.classList.remove("hidden");
        return;
      }
      commentEmptyEl.classList.add("hidden");
      commentListEl.innerHTML = comments
        .map((item) => renderCommentNode(item, 0))
        .join("");
      void refreshMarkdownRuntime();
      collapseCommentCodeBlocks();
    };

    const applyAuthState = (state: AuthState): void => {
      currentUserId = state.isLoggedIn ? state.userId : "";
      isAdmin = state.isLoggedIn && state.isAdmin;
      renderComments();
      if (commentMode === "preview" && previewDirty) {
        void requestPreview(true);
      }
    };

    runtimeWindow._directusCommentApplyAuth = applyAuthState;

    const loadComments = async (): Promise<void> => {
      if (!directusEnabled) return;
      try {
        const response = await fetch(commentApiBase(), {
          headers: { Accept: "application/json" },
          credentials: "include",
        });
        const data = await response.json().catch(() => null);
        if (!response.ok || !data?.ok) {
          comments = [];
          renderComments();
          return;
        }
        comments = Array.isArray(data.items)
          ? (data.items as CommentItem[])
          : [];
        renderComments();
      } catch (error) {
        console.error("[comment] load comments failed:", error);
        comments = [];
        renderComments();
      }
    };

    const resetPreviewState = (): void => {
      previewSource = "";
      previewHtml = "";
      previewError = "";
      previewLoading = false;
      previewDirty = false;
      previewRequestId += 1;
      renderedPreviewHtml = "";
      renderPreview();
    };

    const submitComment = async (): Promise<void> => {
      if (!bodyEl || !submitEl || !parentIdEl) return;

      if (!currentUserId) {
        showAuthRequiredDialog("请先登录后再发表评论。");
        return;
      }

      const body = String(bodyEl.value || "").trim();
      if (!body) {
        setFormError("评论内容不能为空");
        return;
      }

      setFormError("");
      submitEl.disabled = true;
      submitEl.textContent = "提交中...";
      try {
        const response = await fetch(commentApiBase(), {
          method: "POST",
          credentials: "include",
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
          },
          body: JSON.stringify({
            body,
            parent_id: parentIdEl.value || null,
          }),
        });
        const data = await response.json().catch(() => null);
        if (!response.ok || !data?.ok) {
          setFormError(data?.message || "评论提交失败");
          return;
        }
        bodyEl.value = "";
        setReplyState("", "");
        setCommentMode("edit");
        resetPreviewState();
        await loadComments();
      } catch (error) {
        console.error("[comment] submit failed:", error);
        setFormError("评论提交失败，请稍后重试");
      } finally {
        submitEl.disabled = false;
        submitEl.textContent = "发布评论";
      }
    };

    const deleteComment = async (commentId: string): Promise<void> => {
      const confirmed = await showConfirmDialog({
        ariaLabel: "删除确认",
        message: "确认删除这条评论？下方的回复也将一并删除。",
        confirmText: "确认删除",
        cancelText: "取消",
        confirmVariant: "danger",
      });
      if (!confirmed) return;
      const response = await fetch(commentItemApi(commentId), {
        method: "DELETE",
        credentials: "include",
        headers: { Accept: "application/json" },
      });
      const data = await response.json().catch(() => null);
      if (!response.ok || !data?.ok) {
        await showNoticeDialog({
          ariaLabel: "删除失败",
          message: data?.message || "删除失败",
        });
        return;
      }
      await loadComments();
    };

    if (modeEditEl && !modeEditEl.dataset.bound) {
      modeEditEl.dataset.bound = "1";
      modeEditEl.addEventListener("click", () => {
        setCommentMode("edit");
      });
    }

    if (modePreviewEl && !modePreviewEl.dataset.bound) {
      modePreviewEl.dataset.bound = "1";
      modePreviewEl.addEventListener("click", () => {
        setCommentMode("preview");
      });
    }

    if (bodyEl && !bodyEl.dataset.bound) {
      bodyEl.dataset.bound = "1";
      bodyEl.addEventListener("input", () => {
        markPreviewDirty();
      });
      bodyEl.addEventListener("blur", () => {
        if (!previewDirty) return;
        void requestPreview(true);
      });
    }

    if (toolbarEl && !toolbarEl.dataset.bound) {
      toolbarEl.dataset.bound = "1";
      toolbarEl.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof Element)) return;
        const actionEl = target.closest(
          ".comment-toolbar-btn",
        ) as HTMLButtonElement | null;
        if (!actionEl) return;
        const action = String(actionEl.dataset.mdAction || "");
        if (!isToolbarAction(action)) return;
        applyToolbarAction(action);
      });
    }

    if (formEl && !formEl.dataset.bound) {
      formEl.dataset.bound = "1";
      formEl.addEventListener("submit", async (event) => {
        event.preventDefault();
        await submitComment();
      });
    }

    if (replyCancelEl && !replyCancelEl.dataset.bound) {
      replyCancelEl.dataset.bound = "1";
      replyCancelEl.addEventListener("click", () => {
        setReplyState("", "");
      });
    }

    if (commentListEl && !commentListEl.dataset.bound) {
      commentListEl.dataset.bound = "1";
      commentListEl.addEventListener("click", async (event) => {
        const target =
          event.target instanceof HTMLElement ? event.target : null;
        if (!target) return;
        const actionEl = target.closest(".comment-action");
        if (!(actionEl instanceof HTMLElement)) return;
        const action = actionEl.dataset.action || "";
        const id = actionEl.dataset.id || "";
        if (!id) return;

        if (action === "reply") {
          closeAllCommentActionMenus();
          setReplyState(id, actionEl.dataset.author || "用户");
          bodyEl?.focus();
          return;
        }
        if (action === "delete") {
          closeAllCommentActionMenus();
          await deleteComment(id);
        }
      });
    }

    if (!runtimeWindow._directusCommentMenuOutsideBound) {
      runtimeWindow._directusCommentMenuOutsideBound = true;
      document.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof Element)) {
          closeAllCommentActionMenus();
          return;
        }
        if (target.closest(".comment-action-menu")) {
          return;
        }
        closeAllCommentActionMenus();
      });
    }

    if (!runtimeWindow._directusCommentAuthSubscribed) {
      runtimeWindow._directusCommentAuthSubscribed = true;
      subscribeAuthState((state) => {
        runtimeWindow._directusCommentApplyAuth?.(state);
      });
    }

    if (!directusEnabled) return;
    setCommentMode("edit");
    resetPreviewState();
    applyAuthState(getAuthState());
    void loadComments();
  }

  initComments();
  document.addEventListener("astro:after-swap", initComments);
</script>
