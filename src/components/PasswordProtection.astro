---
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";

export interface Props {
  encryptedContent: string;
}

const { encryptedContent } = Astro.props;
---

<div id="password-protection" class="password-protection">
  <div class="password-container">
    <div class="lock-icon">
      <svg
        width="48"
        height="48"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="w-12 h-12"
      >
        <path
          d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"
          fill="currentColor"></path>
      </svg>
    </div>
    <h2>{i18n(I18nKey.passwordProtectedTitle)}</h2>
    <p>{i18n(I18nKey.passwordProtectedDescription)}</p>
    <div class="password-input-group">
      <input
        type="password"
        id="password-input"
        placeholder={i18n(I18nKey.passwordPlaceholder)}
        class="password-input"
        aria-label={i18n(I18nKey.passwordPlaceholder)}
      />
      <button id="unlock-btn" class="unlock-button"
        >{i18n(I18nKey.passwordUnlock)}</button
      >
    </div>
    <div id="error-message" class="error-message" style="display: none;">
      {i18n(I18nKey.passwordIncorrect)}
    </div>
  </div>
</div>

<div
  id="decrypted-content"
  class="decrypted-content w-full"
  style="display: none;"
>
</div>

<style>
  .password-protection {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 60vh;
    padding: 2rem;
  }

  .password-container {
    text-align: center;
    max-width: 25rem;
    width: 100%;
    padding: 2rem;
    border-radius: 12px;
    background: transparent;
    border: 1px solid var(--line-divider);
    box-shadow: none;
  }

  .lock-icon {
    display: flex;
    justify-content: center;
    margin-bottom: 1rem;
    color: var(--primary);
  }

  .lock-icon svg {
    width: 3rem;
    height: 3rem;
  }

  .password-container h2 {
    margin-bottom: 0.5rem;
    color: rgba(0, 0, 0, 0.85);
    font-size: 1.5rem;
  }

  :global(html.dark) .password-container h2 {
    color: rgba(255, 255, 255, 0.85);
  }

  .password-container p {
    margin-bottom: 1.5rem;
    color: rgba(0, 0, 0, 0.75);
    opacity: 0.8;
  }

  :global(html.dark) .password-container p {
    color: rgba(255, 255, 255, 0.75);
  }

  .password-input-group {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    align-items: stretch;
  }

  .password-input {
    flex: 1;
    min-width: 0;
    padding: 0.75rem 1rem;
    border: 1px solid var(--line-divider);
    border-radius: 8px;
    background: transparent;
    color: rgba(0, 0, 0, 0.85);
    font-size: 1rem;
    transition: border-color 0.2s ease;
  }

  :global(html.dark) .password-input {
    color: rgba(255, 255, 255, 0.85);
  }

  .password-input::placeholder {
    color: rgba(0, 0, 0, 0.5);
  }

  :global(html.dark) .password-input::placeholder {
    color: rgba(255, 255, 255, 0.5);
  }

  .password-input:focus {
    outline: none;
    border-color: var(--primary);
  }

  .unlock-button {
    padding: 0.75rem 1.5rem;
    background: transparent;
    color: var(--primary);
    border: 1px solid var(--primary);
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    transition:
      border-color 0.2s,
      color 0.2s,
      background 0.2s;
    white-space: nowrap;
    flex-shrink: 0;
    min-width: fit-content;
    max-width: max-content;
  }

  .unlock-button:hover {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
  }

  .unlock-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .error-message {
    color: #ef4444;
    font-size: 0.875rem;
    margin-top: 0.5rem;
  }

  .decrypted-content {
    animation: fadeIn 0.3s ease-in-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  :global(#decrypted-content .table-wrapper) {
    overflow-x: auto !important;
    width: 100% !important;
  }

  :global(#decrypted-content table) {
    display: table !important;
    width: 100% !important;
  }

  /* Hide encrypted components initially */
  :global(.encrypted-hidden) {
    display: none !important;
  }

  :global(.encrypted-hidden-wrapper.encrypted-hidden) {
    display: none !important;
  }

  @media (min-width: 769px) {
    .password-input-group {
      flex-wrap: nowrap;
    }

    .unlock-button {
      max-width: 40%;
    }
  }

  /* 移动端适配 */

  /* 小屏手机适配 */
</style>

<script
  is:inline
  define:vars={{
    encryptedContent,
    i18nUnlocking: i18n(I18nKey.passwordUnlocking),
    i18nIncorrect: i18n(I18nKey.passwordIncorrect),
    i18nUnlock: i18n(I18nKey.passwordUnlock),
    i18nPasswordRequired: i18n(I18nKey.passwordRequired),
    i18nDecryptionError: i18n(I18nKey.decryptionError),
    i18nPasswordDecryptRetry: i18n(I18nKey.passwordDecryptRetry),
  }}
>
  function fromBase64Url(input) {
    const normalized = String(input || "")
      .replace(/-/g, "+")
      .replace(/_/g, "/");
    const padLength =
      normalized.length % 4 === 0 ? 0 : 4 - (normalized.length % 4);
    const padded = normalized + "=".repeat(padLength);
    const binary = atob(padded);
    const output = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i += 1) {
      output[i] = binary.charCodeAt(i);
    }
    return output;
  }

  function removeUnsafeAttributes(element) {
    const attributes = Array.from(element.attributes || []);
    attributes.forEach((attribute) => {
      const attrName = attribute.name.toLowerCase();
      const attrValue = String(attribute.value || "")
        .trim()
        .toLowerCase();
      if (attrName.startsWith("on")) {
        element.removeAttribute(attribute.name);
        return;
      }
      if (
        (attrName === "href" ||
          attrName === "src" ||
          attrName === "xlink:href") &&
        attrValue.startsWith("javascript:")
      ) {
        element.removeAttribute(attribute.name);
      }
    });
  }

  function sanitizeDecryptedHtml(rawHtml) {
    const parser = new DOMParser();
    const parsed = parser.parseFromString(String(rawHtml || ""), "text/html");
    parsed.querySelectorAll("script,object,embed").forEach((node) => {
      node.remove();
    });
    parsed.querySelectorAll("*").forEach((node) => {
      removeUnsafeAttributes(node);
    });
    return parsed.body.innerHTML;
  }

  async function decryptPayloadV2(input, password) {
    if (!String(input || "").startsWith("DC2:")) {
      throw new Error("UNSUPPORTED_FORMAT");
    }
    if (!window.crypto || !window.crypto.subtle) {
      throw new Error("WEBCRYPTO_UNAVAILABLE");
    }

    const marker = "DACAPO-VERIFY:";
    const decoder = new TextDecoder();
    const encoder = new TextEncoder();
    const encodedPayload = String(input).slice("DC2:".length);
    const payloadJson = decoder.decode(fromBase64Url(encodedPayload));
    const payload = JSON.parse(payloadJson);

    if (
      payload?.v !== 2 ||
      payload?.kdf !== "PBKDF2" ||
      payload?.alg !== "AES-GCM" ||
      typeof payload?.it !== "number"
    ) {
      throw new Error("INVALID_PAYLOAD");
    }

    const keyMaterial = await window.crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      { name: "PBKDF2" },
      false,
      ["deriveKey"],
    );

    const key = await window.crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        hash: "SHA-256",
        salt: fromBase64Url(payload.s),
        iterations: payload.it,
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      false,
      ["decrypt"],
    );

    const decryptedBytes = await window.crypto.subtle.decrypt(
      { name: "AES-GCM", iv: fromBase64Url(payload.iv) },
      key,
      fromBase64Url(payload.ct),
    );
    const decryptedString = decoder.decode(decryptedBytes);

    if (!decryptedString.startsWith(marker)) {
      throw new Error("PASSWORD_INVALID");
    }
    return decryptedString.slice(marker.length);
  }

  async function initPasswordProtection() {
    const savedPassword = sessionStorage.getItem(
      "page-password-" + window.location.pathname,
    );
    const protectionDiv = document.getElementById("password-protection");
    if (savedPassword && protectionDiv) {
      const inputGroup = protectionDiv.querySelector(".password-input-group");
      if (inputGroup) {
        inputGroup.style.visibility = "hidden";
      }
      const hint = protectionDiv.querySelector(".password-container p");
      if (hint) {
        hint.setAttribute("data-original-text", hint.textContent);
        hint.textContent = i18nUnlocking;
      }
      protectionDiv.classList.add("auto-unlocking");
    }

    const passwordInput = document.getElementById("password-input");
    const unlockBtn = document.getElementById("unlock-btn");
    const errorMessage = document.getElementById("error-message");
    const contentDiv = document.getElementById("decrypted-content");
    if (
      !(passwordInput instanceof HTMLInputElement) ||
      !(unlockBtn instanceof HTMLButtonElement) ||
      !(errorMessage instanceof HTMLElement) ||
      !(contentDiv instanceof HTMLElement) ||
      !(protectionDiv instanceof HTMLElement)
    ) {
      return;
    }

    async function attemptUnlock() {
      const inputPassword = passwordInput.value.trim() || savedPassword;

      if (!inputPassword) {
        showError(i18nPasswordRequired);
        return;
      }

      unlockBtn.disabled = true;
      unlockBtn.textContent = i18nUnlocking;
      errorMessage.style.display = "none";

      try {
        const realContent = await decryptPayloadV2(
          encryptedContent,
          inputPassword,
        );
        contentDiv.innerHTML = sanitizeDecryptedHtml(realContent);

        if (protectionDiv && protectionDiv.parentNode) {
          protectionDiv.remove();
        }
        contentDiv.style.display = "block";

        // 显示分享组件和版权信息
        const shareComponent = document.getElementById("share-component");
        const licenseComponent = document.getElementById("license-component");
        if (shareComponent) {
          shareComponent.classList.remove("encrypted-hidden");
        }
        if (licenseComponent) {
          licenseComponent.classList.remove("encrypted-hidden");
        }

        sessionStorage.setItem(
          "page-password-" + window.location.pathname,
          inputPassword,
        );

        // 触发后续处理
        setTimeout(async () => {
          const tocElement = document.querySelector("table-of-contents");
          if (tocElement && typeof tocElement.regenerateTOC === "function") {
            tocElement.regenerateTOC();
            tocElement.init();
          }

          if (typeof Fancybox !== "undefined" && Fancybox.bind) {
            Fancybox.unbind("[data-fancybox]");
            Fancybox.bind("[data-fancybox]", {});
          }

          // 处理 URL 锚点跳转
          window.dispatchEvent(
            new CustomEvent("dacapo:password-content-ready"),
          );

          const images = contentDiv.querySelectorAll("img");
          images.forEach((img) => {
            if (!img.complete) {
              img.addEventListener("load", () => {
                window.dispatchEvent(new Event("scroll"));
                window.dispatchEvent(new Event("resize"));
              });
            }
          });

          [0, 100, 300, 500, 1000, 2000].forEach((delay) => {
            setTimeout(() => {
              window.dispatchEvent(new Event("scroll"));
              window.dispatchEvent(new Event("resize"));
            }, delay);
          });

          // 触发 mermaid 重新渲染
          if (typeof window.renderMermaidDiagrams === "function") {
            await new Promise((resolve) => setTimeout(resolve, 100));
            window.renderMermaidDiagrams();
          }
        }, 50);
      } catch (error) {
        const message = error instanceof Error ? error.message : "";
        if (message === "PASSWORD_INVALID" || message === "OperationError") {
          showError(i18nIncorrect);
          if (savedPassword) {
            sessionStorage.removeItem(
              "page-password-" + window.location.pathname,
            );
            const inputGroup = protectionDiv.querySelector(
              ".password-input-group",
            );
            if (inputGroup instanceof HTMLElement) {
              inputGroup.style.visibility = "visible";
            }
            const hint = protectionDiv.querySelector(".password-container p");
            if (
              hint instanceof HTMLElement &&
              hint.hasAttribute("data-original-text")
            ) {
              hint.textContent = hint.getAttribute("data-original-text");
            }
            passwordInput.value = "";
            protectionDiv.classList.remove("auto-unlocking");
          }
          return;
        }
        console.error(i18nDecryptionError, error);
        showError(i18nPasswordDecryptRetry);
      } finally {
        if (unlockBtn) {
          unlockBtn.disabled = false;
          unlockBtn.textContent = i18nUnlock;
        }
      }
    }

    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.style.display = "block";
      if (!protectionDiv.classList.contains("auto-unlocking")) {
        passwordInput.focus();
      }
    }

    unlockBtn.addEventListener("click", () => attemptUnlock());
    passwordInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        attemptUnlock();
      }
    });

    if (savedPassword) {
      attemptUnlock();
    } else {
      passwordInput.focus();
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initPasswordProtection);
  } else {
    initPasswordProtection();
  }
</script>

<script>
  import { setupCodeCopyDelegation } from "@/scripts/code-copy";
  import { scrollToHashBelowTocBaseline } from "@/utils/hash-scroll";

  type PasswordRuntimeWindow = Window &
    typeof globalThis & {
      __passwordContentHashListenerBound?: boolean;
    };

  const runtimeWindow = window as PasswordRuntimeWindow;

  const handlePasswordContentReady = (): void => {
    if (!window.location.hash) {
      return;
    }

    scrollToHashBelowTocBaseline(window.location.hash, {
      behavior: "smooth",
    });
  };

  if (!runtimeWindow.__passwordContentHashListenerBound) {
    window.addEventListener(
      "dacapo:password-content-ready",
      handlePasswordContentReady,
    );
    runtimeWindow.__passwordContentHashListenerBound = true;
  }

  setupCodeCopyDelegation();
</script>
