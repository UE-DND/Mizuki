---
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";

export interface Props {
	encryptedContent: string;
}

const { encryptedContent } = Astro.props;
---

<div id="password-protection" class="password-protection">
	<div class="password-container">
		<div class="lock-icon">
			<svg
				width="48"
				height="48"
				viewBox="0 0 24 24"
				fill="none"
				xmlns="http://www.w3.org/2000/svg"
                class="w-12 h-12"
			>
				<path
					d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"
					fill="currentColor"></path>
			</svg>
		</div>
		<h2>{i18n(I18nKey.passwordProtectedTitle)}</h2>
		<p>{i18n(I18nKey.passwordProtectedDescription)}</p>
		<div class="password-input-group">
			<input
				type="password"
				id="password-input"
				placeholder={i18n(I18nKey.passwordPlaceholder)}
				class="password-input"
				aria-label={i18n(I18nKey.passwordPlaceholder)}
			/>
			<button id="unlock-btn" class="unlock-button"
				>{i18n(I18nKey.passwordUnlock)}</button
			>
		</div>
		<div id="error-message" class="error-message" style="display: none;">
			{i18n(I18nKey.passwordIncorrect)}
		</div>
	</div>
</div>

<div
	id="decrypted-content"
	class="decrypted-content w-full"
	style="display: none;"
>
</div>

<style>
	.password-protection {
		display: flex;
		justify-content: center;
		align-items: center;
		min-height: 60vh;
		padding: 2rem;
	}

	.password-container {
		text-align: center;
		max-width: 25rem;
		width: 100%;
		padding: 2rem;
		border-radius: 12px;
		background: transparent;
		border: 1px solid var(--line-divider);
		box-shadow: none;
	}

	.lock-icon {
		display: flex;
		justify-content: center;
		margin-bottom: 1rem;
		color: var(--primary);
	}
    
    .lock-icon svg {
        width: 3rem;
        height: 3rem;
    }

	.password-container h2 {
		margin-bottom: 0.5rem;
		color: rgba(0, 0, 0, 0.85);
		font-size: 1.5rem;
	}

	:global(html.dark) .password-container h2 {
		color: rgba(255, 255, 255, 0.85);
	}

	.password-container p {
		margin-bottom: 1.5rem;
		color: rgba(0, 0, 0, 0.75);
		opacity: 0.8;
	}

	:global(html.dark) .password-container p {
		color: rgba(255, 255, 255, 0.75);
	}

	.password-input-group {
		display: flex;
		gap: 0.5rem;
		margin-bottom: 1rem;
		align-items: stretch;
	}

	.password-input {
		flex: 1;
		min-width: 0;
		padding: 0.75rem 1rem;
		border: 1px solid var(--line-divider);
		border-radius: 8px;
		background: transparent;
		color: rgba(0, 0, 0, 0.85);
		font-size: 1rem;
		transition: border-color 0.2s ease;
	}

	:global(html.dark) .password-input {
		color: rgba(255, 255, 255, 0.85);
	}

	.password-input::placeholder {
		color: rgba(0, 0, 0, 0.5);
	}

	:global(html.dark) .password-input::placeholder {
		color: rgba(255, 255, 255, 0.5);
	}

	.password-input:focus {
		outline: none;
		border-color: var(--primary);
	}

	.unlock-button {
		padding: 0.75rem 1.5rem;
		background: transparent;
		color: var(--primary);
		border: 1px solid var(--primary);
		border-radius: 8px;
		font-size: 1rem;
		cursor: pointer;
		transition:
			border-color 0.2s,
			color 0.2s,
			background 0.2s;
		white-space: nowrap;
		flex-shrink: 0;
		min-width: fit-content;
		max-width: max-content;
	}

	.unlock-button:hover {
		background: var(--primary);
		color: white;
		border-color: var(--primary);
	}

	.unlock-button:disabled {
		opacity: 0.6;
		cursor: not-allowed;
	}

	.error-message {
		color: #ef4444;
		font-size: 0.875rem;
		margin-top: 0.5rem;
	}

	.decrypted-content {
		animation: fadeIn 0.3s ease-in-out;
	}

	@keyframes fadeIn {
		from {
			opacity: 0;
			transform: translateY(10px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}

	:global(#decrypted-content .table-wrapper) {
		overflow-x: auto !important;
		width: 100% !important;
	}

	:global(#decrypted-content table) {
		display: table !important;
		width: 100% !important;
	}

	/* Hide encrypted components initially */
	:global(.encrypted-hidden) {
		display: none !important;
	}

	:global(.encrypted-hidden-wrapper.encrypted-hidden) {
		display: none !important;
	}

	@media (min-width: 769px) {
		.password-input-group {
			flex-wrap: nowrap;
		}

		.unlock-button {
			max-width: 40%;
		}
	}

	/* 移动端适配 */
	@media (max-width: 768px) {
		.password-protection {
			padding: 1rem;
			min-height: 50vh;
		}

		.password-container {
			max-width: none;
			width: 100%;
			padding: 1.5rem;
			margin: 0 0.5rem;
		}

		.password-container h2 {
			font-size: 1.25rem;
			margin-bottom: 0.75rem;
		}

		.password-container p {
			font-size: 0.9rem;
			margin-bottom: 1.25rem;
		}

		.password-input-group {
			flex-direction: column;
			gap: 0.75rem;
		}

		.password-input {
			padding: 0.875rem 1rem;
			font-size: 1rem;
			width: 100%;
		}

		.unlock-button {
			padding: 0.875rem 1rem;
			font-size: 1rem;
			max-width: 100%;
			width: 100%;
			white-space: nowrap;
		}

		.error-message {
			font-size: 0.8rem;
			text-align: center;
		}
	}

	/* 小屏手机适配 */
	@media (max-width: 480px) {
		.password-protection {
			padding: 0.75rem;
		}

		.password-container {
			padding: 1.25rem;
			margin: 0 0.25rem;
		}

		.password-container h2 {
			font-size: 1.125rem;
		}

		.password-container p {
			font-size: 0.85rem;
		}

		.password-input {
			padding: 0.75rem 0.875rem;
			font-size: 0.95rem;
		}

		.unlock-button {
			padding: 0.75rem 0.875rem;
			font-size: 0.95rem;
		}
	}
</style>

<script
	is:inline
	define:vars={{
		encryptedContent,
		i18nUnlocking: i18n(I18nKey.passwordUnlocking),
		i18nIncorrect: i18n(I18nKey.passwordIncorrect),
		i18nDecryptError: i18n(I18nKey.passwordDecryptError),
		i18nUnlock: i18n(I18nKey.passwordUnlock),
		i18nCopyFailed: i18n(I18nKey.copyFailed),
		i18nPasswordRequired: i18n(I18nKey.passwordRequired),
		i18nDecryptionError: i18n(I18nKey.decryptionError),
		i18nPasswordDecryptRetry: i18n(I18nKey.passwordDecryptRetry),
	}}
>
	function fromBase64Url(input) {
		const normalized = String(input || "").replace(/-/g, "+").replace(/_/g, "/");
		const padLength = normalized.length % 4 === 0 ? 0 : 4 - (normalized.length % 4);
		const padded = normalized + "=".repeat(padLength);
		const binary = atob(padded);
		const output = new Uint8Array(binary.length);
		for (let i = 0; i < binary.length; i += 1) {
			output[i] = binary.charCodeAt(i);
		}
		return output;
	}

	function removeUnsafeAttributes(element) {
		const attributes = Array.from(element.attributes || []);
		attributes.forEach((attribute) => {
			const attrName = attribute.name.toLowerCase();
			const attrValue = String(attribute.value || "").trim().toLowerCase();
			if (attrName.startsWith("on")) {
				element.removeAttribute(attribute.name);
				return;
			}
			if (
				(attrName === "href" || attrName === "src" || attrName === "xlink:href") &&
				attrValue.startsWith("javascript:")
			) {
				element.removeAttribute(attribute.name);
			}
		});
	}

	function sanitizeDecryptedHtml(rawHtml) {
		const parser = new DOMParser();
		const parsed = parser.parseFromString(String(rawHtml || ""), "text/html");
		parsed.querySelectorAll("script,object,embed").forEach((node) => {
			node.remove();
		});
		parsed.querySelectorAll("*").forEach((node) => {
			removeUnsafeAttributes(node);
		});
		return parsed.body.innerHTML;
	}

	async function decryptPayloadV2(input, password) {
		if (!String(input || "").startsWith("MZK2:")) {
			throw new Error("UNSUPPORTED_FORMAT");
		}
		if (!window.crypto || !window.crypto.subtle) {
			throw new Error("WEBCRYPTO_UNAVAILABLE");
		}

		const marker = "MIZUKI-VERIFY:";
		const decoder = new TextDecoder();
		const encoder = new TextEncoder();
		const encodedPayload = String(input).slice("MZK2:".length);
		const payloadJson = decoder.decode(fromBase64Url(encodedPayload));
		const payload = JSON.parse(payloadJson);

		if (
			payload?.v !== 2 ||
			payload?.kdf !== "PBKDF2" ||
			payload?.alg !== "AES-GCM" ||
			typeof payload?.it !== "number"
		) {
			throw new Error("INVALID_PAYLOAD");
		}

		const keyMaterial = await window.crypto.subtle.importKey(
			"raw",
			encoder.encode(password),
			{ name: "PBKDF2" },
			false,
			["deriveKey"],
		);

		const key = await window.crypto.subtle.deriveKey(
			{
				name: "PBKDF2",
				hash: "SHA-256",
				salt: fromBase64Url(payload.s),
				iterations: payload.it,
			},
			keyMaterial,
			{ name: "AES-GCM", length: 256 },
			false,
			["decrypt"],
		);

		const decryptedBytes = await window.crypto.subtle.decrypt(
			{ name: "AES-GCM", iv: fromBase64Url(payload.iv) },
			key,
			fromBase64Url(payload.ct),
		);
		const decryptedString = decoder.decode(decryptedBytes);

		if (!decryptedString.startsWith(marker)) {
			throw new Error("PASSWORD_INVALID");
		}
		return decryptedString.slice(marker.length);
	}

	async function initPasswordProtection() {
		const savedPassword = sessionStorage.getItem(
			"page-password-" + window.location.pathname,
		);
		const protectionDiv = document.getElementById("password-protection");
		if (savedPassword && protectionDiv) {
			const inputGroup = protectionDiv.querySelector(
				".password-input-group",
			);
			if (inputGroup) {
				inputGroup.style.visibility = "hidden";
			}
			const hint = protectionDiv.querySelector(".password-container p");
			if (hint) {
				hint.setAttribute("data-original-text", hint.textContent);
				hint.textContent = i18nUnlocking;
			}
			protectionDiv.classList.add("auto-unlocking");
		}

		const passwordInput = document.getElementById("password-input");
		const unlockBtn = document.getElementById("unlock-btn");
		const errorMessage = document.getElementById("error-message");
		const contentDiv = document.getElementById("decrypted-content");
		if (
			!(passwordInput instanceof HTMLInputElement) ||
			!(unlockBtn instanceof HTMLButtonElement) ||
			!(errorMessage instanceof HTMLElement) ||
			!(contentDiv instanceof HTMLElement) ||
			!(protectionDiv instanceof HTMLElement)
		) {
			return;
		}

		async function attemptUnlock() {
			const inputPassword = passwordInput.value.trim() || savedPassword;

			if (!inputPassword) {
				showError(i18nPasswordRequired);
				return;
			}

			unlockBtn.disabled = true;
			unlockBtn.textContent = i18nUnlocking;
			errorMessage.style.display = "none";

			try {
				const realContent = await decryptPayloadV2(
					encryptedContent,
					inputPassword,
				);
				contentDiv.innerHTML = sanitizeDecryptedHtml(realContent);

				if (protectionDiv && protectionDiv.parentNode) {
					protectionDiv.remove();
				}
				contentDiv.style.display = "block";

				// 显示分享组件和版权信息
				const shareComponent =
					document.getElementById("share-component");
				const licenseComponent =
					document.getElementById("license-component");
				if (shareComponent) {
					shareComponent.classList.remove("encrypted-hidden");
				}
				if (licenseComponent) {
					licenseComponent.classList.remove("encrypted-hidden");
				}

				sessionStorage.setItem(
					"page-password-" + window.location.pathname,
					inputPassword,
				);

				// 触发后续处理
				setTimeout(async () => {
					if (window.hljs) {
						contentDiv
							.querySelectorAll("pre code")
							.forEach((block) => {
								window.hljs.highlightElement(block);
							});
					}

					const tocElement =
						document.querySelector("table-of-contents");
					if (
						tocElement &&
						typeof tocElement.regenerateTOC === "function"
					) {
						tocElement.regenerateTOC();
						tocElement.init();
					}

					if (typeof window.mobileTOCInit === "function") {
						window.mobileTOCInit();
					}

					if (typeof Fancybox !== "undefined" && Fancybox.bind) {
						Fancybox.unbind("[data-fancybox]");
						Fancybox.bind("[data-fancybox]", {});
					}

					// 处理 URL 锚点跳转
					if (window.location.hash) {
						const targetId = window.location.hash.substring(1);
						const targetElement = document.getElementById(targetId);
						if (targetElement) {
							targetElement.scrollIntoView({
								behavior: "smooth",
							});
						}
					}

					const images = contentDiv.querySelectorAll("img");
					images.forEach((img) => {
						if (!img.complete) {
							img.addEventListener("load", () => {
								window.dispatchEvent(new Event("scroll"));
								window.dispatchEvent(new Event("resize"));
							});
						}
					});

					[0, 100, 300, 500, 1000, 2000].forEach((delay) => {
						setTimeout(() => {
							window.dispatchEvent(new Event("scroll"));
							window.dispatchEvent(new Event("resize"));
						}, delay);
					});

					// 触发 mermaid 重新渲染
					if (typeof window.renderMermaidDiagrams === "function") {
						await new Promise((resolve) =>
							setTimeout(resolve, 100),
						);
						window.renderMermaidDiagrams();
					}
				}, 50);
			} catch (error) {
				const message = error instanceof Error ? error.message : "";
				if (
					message === "PASSWORD_INVALID" ||
					message === "OperationError"
				) {
					showError(i18nIncorrect);
					if (savedPassword) {
						sessionStorage.removeItem(
							"page-password-" + window.location.pathname,
						);
						const inputGroup = protectionDiv.querySelector(
							".password-input-group",
						);
						if (inputGroup instanceof HTMLElement) {
							inputGroup.style.visibility = "visible";
						}
						const hint = protectionDiv.querySelector(
							".password-container p",
						);
						if (
							hint instanceof HTMLElement &&
							hint.hasAttribute("data-original-text")
						) {
							hint.textContent =
								hint.getAttribute("data-original-text");
						}
						passwordInput.value = "";
						protectionDiv.classList.remove("auto-unlocking");
					}
					return;
				}
				console.error(i18nDecryptionError, error);
				showError(i18nPasswordDecryptRetry);
			} finally {
				if (unlockBtn) {
					unlockBtn.disabled = false;
					unlockBtn.textContent = i18nUnlock;
				}
			}
		}

		function showError(message) {
			errorMessage.textContent = message;
			errorMessage.style.display = "block";
			if (!protectionDiv.classList.contains("auto-unlocking")) {
				passwordInput.focus();
			}
		}

		unlockBtn.addEventListener("click", () => attemptUnlock());
		passwordInput.addEventListener("keypress", (e) => {
			if (e.key === "Enter") {
				attemptUnlock();
			}
		});

		if (savedPassword) {
			attemptUnlock();
		} else {
			passwordInput.focus();
		}
	}

	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", initPasswordProtection);
	} else {
		initPasswordProtection();
	}
</script>

<script>
	document.addEventListener("click", function (e: MouseEvent) {
		const target = e.target as HTMLElement | null;
		if (!target) {return;}

		const btn = target.closest(".copy-btn");

		if (btn) {
			const codeEle = btn.parentElement?.querySelector("code");

			if (codeEle) {
				let code = "";

				const lineElements = codeEle.querySelectorAll("span.line");
				if (lineElements.length > 0) {
					const lines: string[] = [];
					for (let i = 0; i < lineElements.length; i++) {
						lines.push(lineElements[i].textContent || "");
					}
					code = lines.join("\n");
				} else {
					const codeElements = codeEle.querySelectorAll(
						".code:not(summary *)",
					);
					if (codeElements.length > 0) {
						const lines: string[] = [];
						for (let i = 0; i < codeElements.length; i++) {
							lines.push(codeElements[i].textContent || "");
						}
						code = lines.join("\n");
					} else {
						code = codeEle.textContent || "";
					}
				}

					code = code.replace(/\n{3,}/g, (match) => {
						const emptyLineCount = match.length - 1;
						const resultEmptyLines = Math.ceil(emptyLineCount / 2);
						return "\n".repeat(resultEmptyLines + 1);
					});

					const copyToClipboard = async (text: string) => {
						if (
							!navigator.clipboard ||
							typeof navigator.clipboard.writeText !== "function"
						) {
							throw new Error("Clipboard API 不可用");
						}
						await navigator.clipboard.writeText(text);
					};

				copyToClipboard(code)
					.then(() => {
						const timeoutId = btn.getAttribute("data-timeout-id");
						if (timeoutId) {
							clearTimeout(parseInt(timeoutId));
						}

						btn.classList.add("success");

						const newTimeoutId = setTimeout(() => {
							btn.classList.remove("success");
						}, 1000);

						btn.setAttribute(
							"data-timeout-id",
							newTimeoutId.toString(),
						);
					})
					.catch((err) => {
						console.error("copy failed:", err);
					});
			}
		}
	});
</script>
