---
import MainGridLayout from "@layouts/MainGridLayout.astro";

export const prerender = false;
---

<MainGridLayout title="账户设置" description="管理个人资料与隐私">
	<div class="space-y-4">
		<section class="card-base p-6 rounded-[var(--radius-large)]">
			<h1 class="text-2xl font-bold mb-2">账户设置</h1>
			<p class="text-sm text-70">管理个人资料与隐私设置。</p>
			<div id="me-auth-message" class="mt-4 text-sm text-70"></div>
		</section>

		<div id="me-authenticated-sections" class="hidden space-y-4">
			<section class="card-base p-6 rounded-[var(--radius-large)] space-y-3">
				<h2 class="text-xl font-semibold">个人资料</h2>
				<form id="me-profile-form" class="grid grid-cols-1 md:grid-cols-2 gap-3">
					<label class="space-y-1">
						<span class="text-xs text-60">邮箱</span>
						<input
							id="me-email"
							class="w-full rounded-lg border border-[var(--line-divider)] px-3 py-2 bg-black/5 dark:bg-white/5 text-70"
							disabled
						/>
					</label>
					<label class="space-y-1">
						<span class="text-xs text-60">用户名</span>
						<button
							type="button"
							id="me-username-display-btn"
							class="w-full appearance-none rounded-lg border border-[var(--line-divider)] px-3 py-2 text-left text-70 bg-black/5 dark:bg-white/5 leading-normal"
						>
							<span id="me-username-display" class="block truncate leading-6 text-70">点击编辑用户名</span>
						</button>
						<div id="me-username-editor" class="relative hidden">
							<input id="me-username" class="w-full rounded-lg border border-[var(--line-divider)] px-3 py-2 pr-14 text-70 bg-transparent" />
							<span id="me-username-counter" class="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 text-xs text-60 tabular-nums">0/14</span>
						</div>
					</label>
					<div class="space-y-2 md:col-span-2">
						<span class="text-xs text-60">头像</span>
						<div class="flex flex-col sm:flex-row sm:items-center gap-3">
							<img
								id="me-avatar-preview"
								class="w-16 h-16 rounded-full object-cover border border-[var(--line-divider)] bg-black/10 dark:bg-white/10"
								alt="avatar"
								loading="lazy"
							/>
							<div class="flex-1 space-y-2">
								<input
									id="me-avatar-url"
									placeholder="头像 URL 或上传图片"
									class="w-full rounded-lg border border-[var(--line-divider)] px-3 py-2 bg-transparent"
								/>
								<div class="flex flex-wrap items-center gap-2">
									<button type="button" id="me-avatar-upload-btn" class="px-3 py-2 rounded-lg border border-[var(--line-divider)] text-xs">
										上传图片
									</button>
									<button type="button" id="me-avatar-clear-btn" class="px-3 py-2 rounded-lg border border-[var(--line-divider)] text-xs">
										清空头像
									</button>
								</div>
							</div>
						</div>
					</div>
					<label class="space-y-1 md:col-span-2">
						<span class="text-xs text-60">简介</span>
						<button
							type="button"
							id="me-bio-display-btn"
							class="w-full h-24 rounded-lg border border-[var(--line-divider)] text-left bg-black/5 dark:bg-white/5"
						>
							<span id="me-bio-display" class="block h-full w-full overflow-y-auto px-3 py-2 pr-14 text-sm leading-6 text-60 whitespace-pre-wrap break-words">点击编辑简介</span>
						</button>
						<div id="me-bio-editor" class="hidden">
							<div class="relative">
								<textarea id="me-bio" rows="3" class="w-full h-24 resize-none rounded-lg border border-[var(--line-divider)] px-3 py-2 pr-14 text-sm leading-6 bg-transparent"></textarea>
								<div id="me-bio-counter" class="pointer-events-none absolute right-3 bottom-2 text-xs text-60 tabular-nums">0/30</div>
							</div>
						</div>
					</label>
					<div class="md:col-span-2 flex items-center gap-2">
						<button type="submit" class="px-4 py-2 rounded-lg bg-[var(--btn-regular-bg)] text-[var(--btn-content)] text-sm">保存资料</button>
						<span id="me-profile-msg" class="text-xs text-60"></span>
					</div>
				</form>
			</section>

			<section class="card-base p-6 rounded-[var(--radius-large)] space-y-3">
				<h2 class="text-xl font-semibold">隐私设置</h2>
				<form id="me-privacy-form" class="grid grid-cols-1 md:grid-cols-2 gap-2 text-sm">
					<label class="flex items-center gap-2"><input type="checkbox" id="pv-profile-public" /> 公开主页</label>
					<label class="flex items-center gap-2"><input type="checkbox" id="pv-show-articles" /> 主页展示文章</label>
					<label class="flex items-center gap-2"><input type="checkbox" id="pv-show-diaries" /> 主页展示日记</label>
					<label class="flex items-center gap-2"><input type="checkbox" id="pv-show-anime" /> 主页展示番剧</label>
					<label class="flex items-center gap-2"><input type="checkbox" id="pv-show-albums" /> 主页展示相册</label>
					<label class="flex items-center gap-2"><input type="checkbox" id="pv-show-comments" /> 主页展示评论</label>
					<div class="md:col-span-2 flex items-center gap-2 pt-2">
						<button type="submit" class="px-4 py-2 rounded-lg bg-[var(--btn-regular-bg)] text-[var(--btn-content)] text-sm">保存隐私设置</button>
						<span id="me-privacy-msg" class="text-xs text-60"></span>
					</div>
				</form>
			</section>
		</div>
	</div>

	</MainGridLayout>

<div
	id="me-avatar-crop-modal"
	class="fixed inset-0 z-[9999] hidden items-center justify-center bg-black/70 px-4 py-5"
	tabindex="-1"
>
	<div class="card-base w-full max-w-xl rounded-[var(--radius-large)] border border-[var(--line-divider)] p-4 sm:p-5 space-y-4">
		<div class="flex items-center gap-2">
			<h3 class="text-base sm:text-lg font-semibold">裁剪头像</h3>
		</div>
		<p class="text-xs text-60">点击“选择文件”后，可拖拽调整位置并通过滑块缩放。</p>
		<div
			id="me-avatar-crop-viewport"
			class="relative mx-auto w-full max-w-[360px] aspect-square overflow-hidden rounded-2xl border border-[var(--line-divider)] bg-black/15 dark:bg-white/10 select-none touch-none"
		>
			<img id="me-avatar-crop-image" class="absolute left-0 top-0 max-w-none pointer-events-none hidden" alt="待裁剪头像" />
			<div
				id="me-avatar-crop-empty"
				class="absolute inset-0 grid place-items-center text-xs text-60 pointer-events-none"
			>
				请选择图片
			</div>
			<div class="absolute inset-0 pointer-events-none rounded-2xl ring-2 ring-white/80"></div>
		</div>
		<div class="space-y-1">
			<label for="me-avatar-crop-zoom" class="text-xs text-60">缩放</label>
			<input id="me-avatar-crop-zoom" type="range" min="100" max="300" step="1" value="100" class="w-full" />
		</div>
		<div class="flex flex-wrap items-center gap-2">
			<input id="me-avatar-crop-file" type="file" accept="image/*" class="hidden" />
			<button type="button" id="me-avatar-crop-select-btn" class="px-3 py-2 rounded-lg border border-[var(--line-divider)] text-xs">
				选择文件
			</button>
			<button type="button" id="me-avatar-crop-apply-btn" class="px-3 py-2 rounded-lg bg-[var(--btn-regular-bg)] text-[var(--btn-content)] text-xs">
				裁剪并上传
			</button>
			<button type="button" id="me-avatar-crop-cancel-btn" class="ml-auto px-3 py-2 rounded-lg border border-[var(--line-divider)] text-xs">
				取消
			</button>
		</div>
		<span id="me-avatar-crop-msg" class="text-xs text-red-500"></span>
	</div>
</div>

<script is:inline>
	(() => {
	const INIT_HOOK_KEY = "__mizuki_me_page_init__";
	const OUTSIDE_CLICK_HOOK_KEY = "__mizuki_me_page_outside_click__";
	const previousInit = window[INIT_HOOK_KEY];
	if (typeof previousInit === "function") {
		document.removeEventListener("astro:after-swap", previousInit);
	}
	const previousOutsideClick = window[OUTSIDE_CLICK_HOOK_KEY];
	if (typeof previousOutsideClick === "function") {
		document.removeEventListener("click", previousOutsideClick);
	}

	const normalizeApiUrl = (input) => {
		const [pathname, search = ""] = String(input || "").split("?");
		const normalizedPath = pathname.endsWith("/") ? pathname : `${pathname}/`;
		return search ? `${normalizedPath}?${search}` : normalizedPath;
	};

	const api = async (url, init = {}) => {
		const isFormData =
			typeof FormData !== "undefined" &&
			Boolean(init.body) &&
			init.body instanceof FormData;
		const response = await fetch(normalizeApiUrl(url), {
			credentials: "include",
			headers: {
				Accept: "application/json",
				...(init.body && !isFormData
					? { "Content-Type": "application/json" }
					: {}),
				...(init.headers || {}),
			},
			...init,
		});
		const data = await response.json().catch(() => null);
		return { response, data };
	};

	const authMessage = document.getElementById("me-auth-message");
	const authenticatedSections = document.getElementById("me-authenticated-sections");
	const profileMsg = document.getElementById("me-profile-msg");
	const privacyMsg = document.getElementById("me-privacy-msg");
	const emailInput = document.getElementById("me-email");
	const usernameDisplayBtn = document.getElementById("me-username-display-btn");
	const usernameDisplayText = document.getElementById("me-username-display");
	const usernameEditor = document.getElementById("me-username-editor");
	const usernameInput = document.getElementById("me-username");
	const usernameCounter = document.getElementById("me-username-counter");
	const bioDisplayBtn = document.getElementById("me-bio-display-btn");
	const bioDisplayText = document.getElementById("me-bio-display");
	const bioEditor = document.getElementById("me-bio-editor");
	const bioInput = document.getElementById("me-bio");
	const bioCounter = document.getElementById("me-bio-counter");
	const avatarPreviewEl = document.getElementById("me-avatar-preview");
	const avatarUrlInput = document.getElementById("me-avatar-url");
	const avatarUploadBtn = document.getElementById("me-avatar-upload-btn");
	const avatarClearBtn = document.getElementById("me-avatar-clear-btn");
	const avatarCropModal = document.getElementById("me-avatar-crop-modal");
	const avatarCropViewport = document.getElementById("me-avatar-crop-viewport");
	const avatarCropImage = document.getElementById("me-avatar-crop-image");
	const avatarCropEmpty = document.getElementById("me-avatar-crop-empty");
	const avatarCropFileInput = document.getElementById("me-avatar-crop-file");
	const avatarCropSelectBtn = document.getElementById("me-avatar-crop-select-btn");
	const avatarCropApplyBtn = document.getElementById("me-avatar-crop-apply-btn");
	const avatarCropCancelBtn = document.getElementById("me-avatar-crop-cancel-btn");
	const avatarCropZoomInput = document.getElementById("me-avatar-crop-zoom");
	const avatarCropMsg = document.getElementById("me-avatar-crop-msg");
	const AUTH_ME_RETRY_DELAY_MS = 220;
	const USERNAME_MAX_WEIGHT = 14;
	const PROFILE_BIO_MAX_LENGTH = 30;
	const AVATAR_CROP_OUTPUT_SIZE = 512;
	const AVATAR_CROP_ZOOM_MIN = 100;
	const AVATAR_CROP_ZOOM_MAX = 300;
	let currentAvatarFileId = "";
	let currentAvatarFallbackUrl = "";
	let avatarCropObjectUrl = "";
	let avatarCropLoaded = false;
	let avatarCropImageWidth = 0;
	let avatarCropImageHeight = 0;
	let avatarCropViewportSize = 0;
	let avatarCropMinScale = 1;
	let avatarCropScale = 1;
	let avatarCropOffsetX = 0;
	let avatarCropOffsetY = 0;
	let avatarCropPointerId = null;
	let avatarCropPointerX = 0;
	let avatarCropPointerY = 0;
	let avatarUploading = false;
	let initTask = null;

	const buildAssetUrl = (fileId) => {
		const normalized = String(fileId || "").trim();
		if (!normalized) {
			return "";
		}
		return `/api/v1/public/assets/${encodeURIComponent(normalized)}/?width=128&height=128&fit=cover`;
	};

	const updateAvatarPreview = () => {
		if (!(avatarPreviewEl instanceof HTMLImageElement)) {
			return;
		}
		const avatarUrl =
			avatarUrlInput instanceof HTMLInputElement
				? String(avatarUrlInput.value || "").trim()
				: "";
		const src =
			avatarUrl ||
			buildAssetUrl(currentAvatarFileId) ||
			currentAvatarFallbackUrl;
		avatarPreviewEl.src =
			src ||
			"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='128' height='128'%3E%3Crect width='128' height='128' fill='%23d1d5db'/%3E%3C/svg%3E";
	};

	const setProfileMessage = (message) => {
		if (!profileMsg) {
			return;
		}
		profileMsg.textContent = message;
	};

	const setCropMessage = (message) => {
		if (!avatarCropMsg) {
			return;
		}
		avatarCropMsg.textContent = message;
	};

	const setUsernameEditing = (editing, focusInput = false) => {
		if (
			!(usernameDisplayBtn instanceof HTMLButtonElement) ||
			!(usernameEditor instanceof HTMLElement)
		) {
			return;
		}
		usernameDisplayBtn.classList.toggle("hidden", editing);
		usernameEditor.classList.toggle("hidden", !editing);
		if (editing && focusInput && usernameInput instanceof HTMLInputElement) {
			window.requestAnimationFrame(() => {
				usernameInput.focus();
				const length = usernameInput.value.length;
				usernameInput.setSelectionRange(length, length);
			});
		}
	};

	const setBioEditing = (editing, focusInput = false) => {
		if (
			!(bioDisplayBtn instanceof HTMLButtonElement) ||
			!(bioEditor instanceof HTMLElement)
		) {
			return;
		}
		bioDisplayBtn.classList.toggle("hidden", editing);
		bioEditor.classList.toggle("hidden", !editing);
		if (editing && focusInput && bioInput instanceof HTMLTextAreaElement) {
			window.requestAnimationFrame(() => {
				bioInput.focus();
				const length = bioInput.value.length;
				bioInput.setSelectionRange(length, length);
			});
		}
	};

	const isHanCharacter = (char) => /[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]/u.test(char);

	const calculateUsernameWeight = (value) => {
		let total = 0;
		for (const char of String(value || "")) {
			total += isHanCharacter(char) ? 2 : 1;
		}
		return total;
	};

	const calculateTextWeight = (value) => {
		let total = 0;
		for (const char of String(value || "")) {
			total += isHanCharacter(char) ? 2 : 1;
		}
		return total;
	};

	const updateUsernameCounter = () => {
		if (
			!(usernameInput instanceof HTMLInputElement) ||
			!(usernameCounter instanceof HTMLElement)
		) {
			return;
		}
		const current = calculateUsernameWeight(
			String(usernameInput.value || "").trim(),
		);
		usernameCounter.textContent = `${current}/${USERNAME_MAX_WEIGHT}`;
	};

	const updateUsernameDisplay = () => {
		if (
			!(usernameDisplayText instanceof HTMLElement) ||
			!(usernameInput instanceof HTMLInputElement)
		) {
			return;
		}
		const text = String(usernameInput.value || "").trim();
		const hasValue = Boolean(text);
		usernameDisplayText.textContent = hasValue ? text : "点击编辑用户名";
		usernameDisplayText.classList.toggle("text-60", !hasValue);
	};

	const updateBioCounter = () => {
		if (
			!(bioInput instanceof HTMLTextAreaElement) ||
			!(bioCounter instanceof HTMLElement)
		) {
			return;
		}
		const current = calculateTextWeight(String(bioInput.value || ""));
		bioCounter.textContent = `${current}/${PROFILE_BIO_MAX_LENGTH}`;
	};

	const updateBioDisplay = () => {
		if (
			!(bioDisplayText instanceof HTMLElement) ||
			!(bioInput instanceof HTMLTextAreaElement)
		) {
			return;
		}
		const text = String(bioInput.value || "").trim();
		const hasValue = Boolean(text);
		bioDisplayText.textContent = hasValue ? text : "点击编辑简介";
		bioDisplayText.classList.toggle("text-60", !hasValue);
	};

	const validateUsernameInput = () => {
		if (!(usernameInput instanceof HTMLInputElement)) {
			return null;
		}
		const raw = String(usernameInput.value || "").trim();
		if (!raw) {
			return "用户名不能为空";
		}
		if (!/^[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFFA-Za-z0-9_-]+$/u.test(raw)) {
			return "用户名仅支持中文、英文、数字、下划线和短横线";
		}
		if (calculateUsernameWeight(raw) > USERNAME_MAX_WEIGHT) {
			return "用户名最多 14 字符（中文按 2 字符计）";
		}
		return null;
	};

	const validateBioInput = () => {
		if (!(bioInput instanceof HTMLTextAreaElement)) {
			return null;
		}
		if (calculateTextWeight(String(bioInput.value || "")) > PROFILE_BIO_MAX_LENGTH) {
			return "个人简介最多 30 字符（中文按 2 字符计）";
		}
		return null;
	};

	const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

	const revokeAvatarCropObjectUrl = () => {
		if (avatarCropObjectUrl) {
			URL.revokeObjectURL(avatarCropObjectUrl);
			avatarCropObjectUrl = "";
		}
	};

	const setAvatarCropEmptyVisible = (visible) => {
		if (!(avatarCropEmpty instanceof HTMLElement)) {
			return;
		}
		avatarCropEmpty.classList.toggle("hidden", !visible);
	};

	const setAvatarCropApplyEnabled = (enabled) => {
		if (!(avatarCropApplyBtn instanceof HTMLButtonElement)) {
			return;
		}
		avatarCropApplyBtn.disabled = !enabled;
	};

	const updateAvatarCropApplyState = () => {
		setAvatarCropApplyEnabled(avatarCropLoaded && !avatarUploading);
		if (avatarCropApplyBtn instanceof HTMLButtonElement) {
			avatarCropApplyBtn.textContent = avatarUploading ? "上传中..." : "裁剪并上传";
		}
	};

	const resetAvatarCropState = () => {
		revokeAvatarCropObjectUrl();
		avatarCropLoaded = false;
		avatarCropImageWidth = 0;
		avatarCropImageHeight = 0;
		avatarCropViewportSize = 0;
		avatarCropMinScale = 1;
		avatarCropScale = 1;
		avatarCropOffsetX = 0;
		avatarCropOffsetY = 0;
		avatarCropPointerId = null;
		avatarCropPointerX = 0;
		avatarCropPointerY = 0;
		if (avatarCropImage instanceof HTMLImageElement) {
			avatarCropImage.removeAttribute("src");
			avatarCropImage.classList.add("hidden");
			avatarCropImage.style.transform = "";
			avatarCropImage.style.width = "";
			avatarCropImage.style.height = "";
			avatarCropImage.style.transformOrigin = "top left";
		}
		if (avatarCropZoomInput instanceof HTMLInputElement) {
			avatarCropZoomInput.value = String(AVATAR_CROP_ZOOM_MIN);
		}
		setAvatarCropEmptyVisible(true);
		updateAvatarCropApplyState();
	};

	const openAvatarCropModal = () => {
		if (!(avatarCropModal instanceof HTMLElement)) {
			setProfileMessage("裁剪层初始化失败");
			return;
		}
		avatarCropModal.classList.remove("hidden");
		avatarCropModal.classList.add("flex");
		document.body.classList.add("overflow-hidden");
		avatarCropModal.focus();
	};

	const closeAvatarCropModal = () => {
		if (!(avatarCropModal instanceof HTMLElement)) {
			return;
		}
		avatarCropModal.classList.remove("flex");
		avatarCropModal.classList.add("hidden");
		document.body.classList.remove("overflow-hidden");
		if (avatarCropFileInput instanceof HTMLInputElement) {
			avatarCropFileInput.value = "";
		}
		resetAvatarCropState();
		avatarUploading = false;
		updateAvatarCropApplyState();
		setCropMessage("");
	};

	const measureAvatarCropViewportSize = () => {
		if (!(avatarCropViewport instanceof HTMLElement)) {
			return 0;
		}
		const rect = avatarCropViewport.getBoundingClientRect();
		return Math.max(0, Math.floor(Math.min(rect.width, rect.height)));
	};

	const clampAvatarCropOffset = () => {
		if (!avatarCropLoaded || avatarCropViewportSize <= 0) {
			return;
		}
		const scaledWidth = avatarCropImageWidth * avatarCropScale;
		const scaledHeight = avatarCropImageHeight * avatarCropScale;
		const minX = avatarCropViewportSize - scaledWidth;
		const minY = avatarCropViewportSize - scaledHeight;
		avatarCropOffsetX = clamp(avatarCropOffsetX, minX, 0);
		avatarCropOffsetY = clamp(avatarCropOffsetY, minY, 0);
	};

	const renderAvatarCropImage = () => {
		if (!(avatarCropImage instanceof HTMLImageElement)) {
			return;
		}
		if (!avatarCropLoaded) {
			avatarCropImage.classList.add("hidden");
			setAvatarCropEmptyVisible(true);
			return;
		}
		clampAvatarCropOffset();
		avatarCropImage.classList.remove("hidden");
		avatarCropImage.style.width = `${avatarCropImageWidth}px`;
		avatarCropImage.style.height = `${avatarCropImageHeight}px`;
		avatarCropImage.style.transformOrigin = "top left";
		avatarCropImage.style.transform = `translate3d(${avatarCropOffsetX}px, ${avatarCropOffsetY}px, 0) scale(${avatarCropScale})`;
		setAvatarCropEmptyVisible(false);
	};

	const setAvatarCropScaleFromZoom = (zoomPercent, anchorX, anchorY) => {
		if (!avatarCropLoaded || avatarCropViewportSize <= 0) {
			return;
		}
		const normalizedZoom = clamp(
			Number.isFinite(zoomPercent) ? zoomPercent : AVATAR_CROP_ZOOM_MIN,
			AVATAR_CROP_ZOOM_MIN,
			AVATAR_CROP_ZOOM_MAX,
		);
		const nextScale = avatarCropMinScale * (normalizedZoom / 100);
		const safeAnchorX = clamp(anchorX, 0, avatarCropViewportSize);
		const safeAnchorY = clamp(anchorY, 0, avatarCropViewportSize);
		const imagePointX = (safeAnchorX - avatarCropOffsetX) / avatarCropScale;
		const imagePointY = (safeAnchorY - avatarCropOffsetY) / avatarCropScale;
		avatarCropScale = nextScale;
		avatarCropOffsetX = safeAnchorX - imagePointX * avatarCropScale;
		avatarCropOffsetY = safeAnchorY - imagePointY * avatarCropScale;
		clampAvatarCropOffset();
		renderAvatarCropImage();
		if (avatarCropZoomInput instanceof HTMLInputElement) {
			avatarCropZoomInput.value = String(Math.round(normalizedZoom));
		}
	};

	const loadAvatarCropFile = (file) => {
		if (!(avatarCropImage instanceof HTMLImageElement)) {
			setCropMessage("裁剪层初始化失败");
			return;
		}
		if (!file.type.startsWith("image/")) {
			setCropMessage("请选择图片文件");
			return;
		}
		const AVATAR_MAX_SIZE = 1.5 * 1024 * 1024; // 1.5 MB
		if (file.size > AVATAR_MAX_SIZE) {
			setCropMessage("图片文件过大，请选择不超过 1.5 MB 的图片");
			return;
		}
		setCropMessage("");
		const nextObjectUrl = URL.createObjectURL(file);
		avatarCropImage.onload = () => {
			avatarCropLoaded = true;
			avatarCropImageWidth = Math.max(1, avatarCropImage.naturalWidth);
			avatarCropImageHeight = Math.max(1, avatarCropImage.naturalHeight);
			avatarCropViewportSize = measureAvatarCropViewportSize();
			if (avatarCropViewportSize <= 0) {
				avatarCropViewportSize = 320;
			}
			avatarCropMinScale = Math.max(
				avatarCropViewportSize / avatarCropImageWidth,
				avatarCropViewportSize / avatarCropImageHeight,
			);
			avatarCropScale = avatarCropMinScale;
			avatarCropOffsetX = (avatarCropViewportSize - avatarCropImageWidth * avatarCropScale) / 2;
			avatarCropOffsetY = (avatarCropViewportSize - avatarCropImageHeight * avatarCropScale) / 2;
			if (avatarCropZoomInput instanceof HTMLInputElement) {
				avatarCropZoomInput.value = String(AVATAR_CROP_ZOOM_MIN);
			}
			renderAvatarCropImage();
			updateAvatarCropApplyState();
			setProfileMessage("");
		};
		avatarCropImage.onerror = () => {
			setCropMessage("图片读取失败，请重试");
			resetAvatarCropState();
		};
		revokeAvatarCropObjectUrl();
		avatarCropObjectUrl = nextObjectUrl;
		avatarCropImage.src = nextObjectUrl;
	};

	const buildAvatarCropBlob = async () => {
		if (!avatarCropLoaded || !(avatarCropImage instanceof HTMLImageElement)) {
			return null;
		}
		if (avatarCropViewportSize <= 0) {
			return null;
		}
		const canvas = document.createElement("canvas");
		canvas.width = AVATAR_CROP_OUTPUT_SIZE;
		canvas.height = AVATAR_CROP_OUTPUT_SIZE;
		const context = canvas.getContext("2d");
		if (!context) {
			return null;
		}
		const ratio = AVATAR_CROP_OUTPUT_SIZE / avatarCropViewportSize;
		context.imageSmoothingEnabled = true;
		context.imageSmoothingQuality = "high";
		context.clearRect(0, 0, canvas.width, canvas.height);
		context.drawImage(
			avatarCropImage,
			avatarCropOffsetX * ratio,
			avatarCropOffsetY * ratio,
			avatarCropImageWidth * avatarCropScale * ratio,
			avatarCropImageHeight * avatarCropScale * ratio,
		);
		return await new Promise((resolve) => {
			canvas.toBlob((blob) => resolve(blob), "image/jpeg", 0.92);
		});
	};

	const uploadAvatarFromCrop = async () => {
		if (!avatarCropLoaded) {
			setCropMessage("请先选择头像文件");
			return;
		}
		avatarUploading = true;
		updateAvatarCropApplyState();
		try {
			const croppedBlob = await buildAvatarCropBlob();
			if (!croppedBlob) {
				setCropMessage("头像裁剪失败");
				return;
			}
			const formData = new FormData();
			formData.append("file", croppedBlob, `avatar-${Date.now()}.jpg`);
			formData.append("title", `avatar-${Date.now()}`);
			const { response, data } = await api("/api/v1/uploads", {
				method: "POST",
				body: formData,
			});
			if (!response.ok || !data?.ok || !data?.file?.id) {
				setCropMessage(data?.message || "头像上传失败");
				return;
			}
			currentAvatarFileId = String(data.file.id);
			if (avatarUrlInput instanceof HTMLInputElement) {
				avatarUrlInput.value = "";
			}
			updateAvatarPreview();
			closeAvatarCropModal();
			setProfileMessage("头像上传成功，请点击“保存资料”生效");
		} finally {
			avatarUploading = false;
			updateAvatarCropApplyState();
		}
	};

	resetAvatarCropState();
	updateAvatarPreview();

	const extractFileId = (value) => {
		if (!value) {
			return "";
		}
		if (typeof value === "string") {
			return value.trim();
		}
		if (
			typeof value === "object" &&
			value !== null &&
			"id" in value &&
			typeof value.id === "string"
		) {
			return String(value.id || "").trim();
		}
		return "";
	};

	const fillProfile = (profile, fallbackAvatarUrl = "") => {
		if (usernameInput instanceof HTMLInputElement) {
			usernameInput.value = profile?.username || "";
			updateUsernameCounter();
			updateUsernameDisplay();
			setUsernameEditing(false);
		}
		if (avatarUrlInput instanceof HTMLInputElement) {
			avatarUrlInput.value = profile?.avatar_url || "";
		}
		currentAvatarFileId = extractFileId(profile?.avatar_file);
		currentAvatarFallbackUrl = String(fallbackAvatarUrl || "").trim();
		updateAvatarPreview();
		if (bioInput instanceof HTMLTextAreaElement) {
			bioInput.value = profile?.bio || "";
			updateBioCounter();
			updateBioDisplay();
			setBioEditing(false);
		}
	};

	const fillPrivacy = (privacy) => {
		document.getElementById("pv-profile-public").checked = Boolean(privacy?.profile_public);
		document.getElementById("pv-show-articles").checked = Boolean(privacy?.show_articles_on_profile);
		document.getElementById("pv-show-diaries").checked = Boolean(privacy?.show_diaries_on_profile);
		document.getElementById("pv-show-anime").checked = Boolean(privacy?.show_anime_on_profile);
		document.getElementById("pv-show-albums").checked = Boolean(privacy?.show_albums_on_profile);
		document.getElementById("pv-show-comments").checked = Boolean(privacy?.show_comments_on_profile);
	};

	const loadAuthMe = async () => {
		let result = await api("/api/auth/me/");
		if (
			(!result.response.ok || !result.data?.ok) &&
			result.response.status === 401
		) {
			await new Promise((resolve) =>
				window.setTimeout(resolve, AUTH_ME_RETRY_DELAY_MS),
			);
			result = await api("/api/auth/me/");
		}
		return result;
	};

	const buildLoginRedirectHref = () => {
		const pathname = String(window.location.pathname || "/");
		const search = String(window.location.search || "");
		const hash = String(window.location.hash || "");
		const redirect = `${pathname}${search}${hash}` || "/";
		if (!redirect.startsWith("/") || redirect.startsWith("//")) {
			return "/login/";
		}
		return `/login/?redirect=${encodeURIComponent(redirect)}`;
	};

	const init = async () => {
		const normalizedPath = window.location.pathname.replace(/\/+$/, "") || "/";
		if (normalizedPath !== "/me") {
			return;
		}
		if (!(authMessage instanceof HTMLElement)) {
			return;
		}

		if (initTask) {
			await initTask;
			return;
		}

		initTask = (async () => {
			if (authenticatedSections instanceof HTMLElement) {
				authenticatedSections.classList.add("hidden");
			}
			authMessage.textContent = "正在验证登录状态…";
			const me = await loadAuthMe();
			if (!me.response.ok || !me.data?.ok) {
				authMessage.innerHTML = `未登录账户，请先 <a href="${buildLoginRedirectHref()}" class="text-[var(--primary)] underline">登录</a>。`;
				return;
			}
			const loginEmail = String(me.data.user?.email || "").trim();
			const fallbackAvatarUrl = String(me.data.user?.avatarUrl || "").trim();
			if (emailInput instanceof HTMLInputElement) {
				emailInput.value = loginEmail;
			}
			currentAvatarFallbackUrl = fallbackAvatarUrl;
			updateAvatarPreview();
			authMessage.textContent = "";

			const [profileResp, privacyResp] = await Promise.all([
				api("/api/v1/me/profile"),
				api("/api/v1/me/privacy"),
			]);
			if (profileResp.response.ok && profileResp.data?.ok) {
				fillProfile(profileResp.data.profile, fallbackAvatarUrl);
			}
			if (privacyResp.response.ok && privacyResp.data?.ok) {
				fillPrivacy(privacyResp.data.privacy);
			}
			if (authenticatedSections instanceof HTMLElement) {
				authenticatedSections.classList.remove("hidden");
			}
		})();

		try {
			await initTask;
		} finally {
			initTask = null;
		}
	};

	document.getElementById("me-profile-form")?.addEventListener("submit", async (event) => {
		event.preventDefault();
		const usernameError = validateUsernameInput();
		if (usernameError) {
			setProfileMessage(usernameError);
			return;
		}
		const bioError = validateBioInput();
		if (bioError) {
			setProfileMessage(bioError);
			return;
		}
		const avatarUrl =
			avatarUrlInput instanceof HTMLInputElement
				? String(avatarUrlInput.value || "").trim()
				: "";
		const payload = {
			username:
				usernameInput instanceof HTMLInputElement ? usernameInput.value : "",
			bio: bioInput instanceof HTMLTextAreaElement ? bioInput.value : "",
			avatar_url: avatarUrl || null,
			avatar_file: avatarUrl ? null : currentAvatarFileId || null,
		};
		const { response, data } = await api("/api/v1/me/profile", {
			method: "PATCH",
			body: JSON.stringify(payload),
		});
		if (!response.ok || !data?.ok) {
			setProfileMessage(data?.message || "保存失败");
			return;
		}
		setProfileMessage("已保存，正在刷新...");
		window.setTimeout(() => {
			window.location.reload();
		}, 120);
	});

	avatarUrlInput?.addEventListener("input", () => {
		updateAvatarPreview();
	});

	usernameInput?.addEventListener("input", () => {
		updateUsernameCounter();
		updateUsernameDisplay();
	});

	bioInput?.addEventListener("input", () => {
		updateBioCounter();
		updateBioDisplay();
	});

	usernameDisplayBtn?.addEventListener("click", () => {
		setUsernameEditing(true, true);
	});

	bioDisplayBtn?.addEventListener("click", () => {
		setBioEditing(true, true);
	});

	const handleOutsideClick = (event) => {
		const target = event.target;
		if (!(target instanceof Node)) {
			return;
		}
		if (
			usernameEditor instanceof HTMLElement &&
			!usernameEditor.classList.contains("hidden")
		) {
			const insideUsernameEditor = usernameEditor.contains(target);
			const insideUsernameDisplay =
				usernameDisplayBtn instanceof HTMLElement &&
				usernameDisplayBtn.contains(target);
			if (!insideUsernameEditor && !insideUsernameDisplay) {
				setUsernameEditing(false);
			}
		}
		if (
			bioEditor instanceof HTMLElement &&
			!bioEditor.classList.contains("hidden")
		) {
			const insideBioEditor = bioEditor.contains(target);
			const insideBioDisplay =
				bioDisplayBtn instanceof HTMLElement &&
				bioDisplayBtn.contains(target);
			if (!insideBioEditor && !insideBioDisplay) {
				setBioEditing(false);
			}
		}
	};
	document.addEventListener("click", handleOutsideClick);
	window[OUTSIDE_CLICK_HOOK_KEY] = handleOutsideClick;

	avatarUploadBtn?.addEventListener("click", () => {
		openAvatarCropModal();
		setProfileMessage("");
	});

	avatarCropSelectBtn?.addEventListener("click", () => {
		if (!(avatarCropFileInput instanceof HTMLInputElement)) {
			return;
		}
		avatarCropFileInput.click();
	});

	avatarCropFileInput?.addEventListener("change", () => {
		if (!(avatarCropFileInput instanceof HTMLInputElement)) {
			return;
		}
		const file = avatarCropFileInput.files?.[0];
		if (!file) {
			return;
		}
		loadAvatarCropFile(file);
	});

	avatarCropZoomInput?.addEventListener("input", () => {
		if (!(avatarCropZoomInput instanceof HTMLInputElement)) {
			return;
		}
		const zoom = Number.parseFloat(avatarCropZoomInput.value || String(AVATAR_CROP_ZOOM_MIN));
		const anchor = avatarCropViewportSize > 0 ? avatarCropViewportSize / 2 : 0;
		setAvatarCropScaleFromZoom(zoom, anchor, anchor);
	});

	avatarCropApplyBtn?.addEventListener("click", async () => {
		await uploadAvatarFromCrop();
	});

	avatarCropCancelBtn?.addEventListener("click", () => {
		if (!avatarUploading) {
			closeAvatarCropModal();
		}
	});

	avatarCropModal?.addEventListener("click", (event) => {
		if (!avatarUploading && event.target === avatarCropModal) {
			closeAvatarCropModal();
		}
	});

	avatarCropModal?.addEventListener("keydown", (event) => {
		if (event.key === "Escape" && !avatarUploading) {
			closeAvatarCropModal();
		}
	});

	avatarCropViewport?.addEventListener("pointerdown", (event) => {
		if (!avatarCropLoaded || !(avatarCropViewport instanceof HTMLElement)) {
			return;
		}
		avatarCropPointerId = event.pointerId;
		avatarCropPointerX = event.clientX;
		avatarCropPointerY = event.clientY;
		avatarCropViewport.setPointerCapture(event.pointerId);
		event.preventDefault();
	});

	avatarCropViewport?.addEventListener("pointermove", (event) => {
		if (!avatarCropLoaded || avatarCropPointerId !== event.pointerId) {
			return;
		}
		const deltaX = event.clientX - avatarCropPointerX;
		const deltaY = event.clientY - avatarCropPointerY;
		avatarCropPointerX = event.clientX;
		avatarCropPointerY = event.clientY;
		avatarCropOffsetX += deltaX;
		avatarCropOffsetY += deltaY;
		renderAvatarCropImage();
		event.preventDefault();
	});

	const releaseAvatarCropPointer = (event) => {
		if (
			avatarCropPointerId !== event.pointerId ||
			!(avatarCropViewport instanceof HTMLElement)
		) {
			return;
		}
		if (avatarCropViewport.hasPointerCapture(event.pointerId)) {
			avatarCropViewport.releasePointerCapture(event.pointerId);
		}
		avatarCropPointerId = null;
	};

	avatarCropViewport?.addEventListener("pointerup", releaseAvatarCropPointer);
	avatarCropViewport?.addEventListener("pointercancel", releaseAvatarCropPointer);

	avatarClearBtn?.addEventListener("click", () => {
		currentAvatarFileId = "";
		currentAvatarFallbackUrl = "";
		if (avatarUrlInput instanceof HTMLInputElement) {
			avatarUrlInput.value = "";
		}
		if (avatarCropFileInput instanceof HTMLInputElement) {
			avatarCropFileInput.value = "";
		}
		updateAvatarPreview();
		setProfileMessage("已清空头像，点击“保存资料”生效");
	});

	document.getElementById("me-privacy-form")?.addEventListener("submit", async (event) => {
		event.preventDefault();
		const payload = {
			profile_public: document.getElementById("pv-profile-public").checked,
			show_articles_on_profile: document.getElementById("pv-show-articles").checked,
			show_diaries_on_profile: document.getElementById("pv-show-diaries").checked,
			show_anime_on_profile: document.getElementById("pv-show-anime").checked,
			show_albums_on_profile: document.getElementById("pv-show-albums").checked,
			show_comments_on_profile: document.getElementById("pv-show-comments").checked,
		};
		const { response, data } = await api("/api/v1/me/privacy", {
			method: "PATCH",
			body: JSON.stringify(payload),
		});
		privacyMsg.textContent = response.ok && data?.ok ? "已保存" : data?.message || "保存失败";
	});

	window[INIT_HOOK_KEY] = init;
	updateUsernameCounter();
	updateBioCounter();
	updateUsernameDisplay();
	updateBioDisplay();
	setUsernameEditing(false);
	setBioEditing(false);
	init();
	document.addEventListener("astro:after-swap", init);
	})();
</script>
